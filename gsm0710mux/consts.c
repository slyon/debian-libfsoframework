/* consts.c generated by valac 0.16.1, the Vala compiler
 * generated from consts.vala, do not modify */

/*
 * const.vala: constants and helper functions
 *
 * (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>

#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

typedef enum  {
	GSM0710MUX_MUXER_ERROR_CHANNEL_TAKEN,
	GSM0710MUX_MUXER_ERROR_INVALID_CHANNEL,
	GSM0710MUX_MUXER_ERROR_INVALID_TRANSPORT,
	GSM0710MUX_MUXER_ERROR_NO_SESSION,
	GSM0710MUX_MUXER_ERROR_NO_CHANNEL,
	GSM0710MUX_MUXER_ERROR_SESSION_ALREADY_OPEN,
	GSM0710MUX_MUXER_ERROR_SESSION_OPEN_ERROR
} Gsm0710muxMuxerError;
#define GSM0710MUX_MUXER_ERROR gsm0710mux_muxer_error_quark ()


GQuark gsm0710mux_muxer_error_quark (void);
#define CONST_LIBGSM0710MUX_CONFIG_SECTION "libgsm0710mux"
#define CONST_LIBGSM0710MUX_LOGGING_DOMAIN "libgsm0710mux"
#define CONST_GSM_PING_SEND_TIMEOUT ((guint) 5)
#define CONST_GSM_PING_RESPONSE_TIMEOUT ((guint) 3)
#define CONST_TRANSPORT_READ_PRIORITY (-20)
#define CONST_TRANSPORT_WRITE_PRIORITY 0
void const_hexdump (gboolean write, void* data, gint len, FsoFrameworkLogger* logger);


GQuark gsm0710mux_muxer_error_quark (void) {
	return g_quark_from_static_string ("gsm0710mux_muxer_error-quark");
}


void const_hexdump (gboolean write, void* data, gint len, FsoFrameworkLogger* logger) {
	gint _tmp0_;
	gint BYTES_PER_LINE;
	void* _tmp1_;
	guchar* pointer;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_;
	const gchar* _tmp4_;
	GString* _tmp5_;
	GString* hexline;
	GString* _tmp6_;
	GString* ascline;
	guchar b = '\0';
	gint i = 0;
	gint _tmp38_;
	gint _tmp39_;
	gint _tmp40_;
	g_return_if_fail (logger != NULL);
	_tmp0_ = len;
	if (_tmp0_ < 1) {
		return;
	}
	BYTES_PER_LINE = 16;
	_tmp1_ = data;
	pointer = (guchar*) _tmp1_;
	_tmp3_ = write;
	if (_tmp3_) {
		_tmp2_ = ">>> ";
	} else {
		_tmp2_ = "<<< ";
	}
	_tmp4_ = _tmp2_;
	_tmp5_ = g_string_new (_tmp4_);
	hexline = _tmp5_;
	_tmp6_ = g_string_new ("");
	ascline = _tmp6_;
	{
		gboolean _tmp7_;
		i = 0;
		_tmp7_ = TRUE;
		while (TRUE) {
			gboolean _tmp8_;
			gint _tmp10_;
			gint _tmp11_;
			guchar* _tmp12_;
			gint _tmp13_;
			guchar _tmp14_;
			GString* _tmp15_;
			guchar _tmp16_;
			gboolean _tmp17_ = FALSE;
			guchar _tmp18_;
			gboolean _tmp20_;
			gint _tmp24_;
			gint _tmp25_;
			gint _tmp26_;
			_tmp8_ = _tmp7_;
			if (!_tmp8_) {
				gint _tmp9_;
				_tmp9_ = i;
				i = _tmp9_ + 1;
			}
			_tmp7_ = FALSE;
			_tmp10_ = i;
			_tmp11_ = len;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = pointer;
			_tmp13_ = i;
			_tmp14_ = _tmp12_[_tmp13_];
			b = _tmp14_;
			_tmp15_ = hexline;
			_tmp16_ = b;
			g_string_append_printf (_tmp15_, "%02X ", (guint) _tmp16_);
			_tmp18_ = b;
			if (31 < ((gint) _tmp18_)) {
				guchar _tmp19_;
				_tmp19_ = b;
				_tmp17_ = ((gint) _tmp19_) < 128;
			} else {
				_tmp17_ = FALSE;
			}
			_tmp20_ = _tmp17_;
			if (_tmp20_) {
				GString* _tmp21_;
				guchar _tmp22_;
				_tmp21_ = ascline;
				_tmp22_ = b;
				g_string_append_printf (_tmp21_, "%c", (gint) _tmp22_);
			} else {
				GString* _tmp23_;
				_tmp23_ = ascline;
				g_string_append_printf (_tmp23_, ".");
			}
			_tmp24_ = i;
			_tmp25_ = BYTES_PER_LINE;
			_tmp26_ = BYTES_PER_LINE;
			if (((_tmp24_ % _tmp25_) + 1) == _tmp26_) {
				GString* _tmp27_;
				GString* _tmp28_;
				const gchar* _tmp29_;
				FsoFrameworkLogger* _tmp30_;
				GString* _tmp31_;
				const gchar* _tmp32_;
				const gchar* _tmp33_ = NULL;
				gboolean _tmp34_;
				const gchar* _tmp35_;
				GString* _tmp36_;
				GString* _tmp37_;
				_tmp27_ = hexline;
				_tmp28_ = ascline;
				_tmp29_ = _tmp28_->str;
				g_string_append (_tmp27_, _tmp29_);
				_tmp30_ = logger;
				_tmp31_ = hexline;
				_tmp32_ = _tmp31_->str;
				fso_framework_logger_debug (_tmp30_, _tmp32_);
				_tmp34_ = write;
				if (_tmp34_) {
					_tmp33_ = ">>> ";
				} else {
					_tmp33_ = "<<< ";
				}
				_tmp35_ = _tmp33_;
				_tmp36_ = g_string_new (_tmp35_);
				_g_string_free0 (hexline);
				hexline = _tmp36_;
				_tmp37_ = g_string_new ("");
				_g_string_free0 (ascline);
				ascline = _tmp37_;
			}
		}
	}
	_tmp38_ = i;
	_tmp39_ = BYTES_PER_LINE;
	_tmp40_ = BYTES_PER_LINE;
	if (((_tmp38_ % _tmp39_) + 1) != _tmp40_) {
		GString* _tmp44_;
		GString* _tmp45_;
		const gchar* _tmp46_;
		FsoFrameworkLogger* _tmp47_;
		GString* _tmp48_;
		const gchar* _tmp49_;
		while (TRUE) {
			GString* _tmp41_;
			gssize _tmp42_;
			GString* _tmp43_;
			_tmp41_ = hexline;
			_tmp42_ = _tmp41_->len;
			if (!(_tmp42_ < ((gssize) 52))) {
				break;
			}
			_tmp43_ = hexline;
			g_string_append_c (_tmp43_, ' ');
		}
		_tmp44_ = hexline;
		_tmp45_ = ascline;
		_tmp46_ = _tmp45_->str;
		g_string_append (_tmp44_, _tmp46_);
		_tmp47_ = logger;
		_tmp48_ = hexline;
		_tmp49_ = _tmp48_->str;
		fso_framework_logger_debug (_tmp47_, _tmp49_);
	}
	_g_string_free0 (ascline);
	_g_string_free0 (hexline);
}



