/* transport.c generated by valac 0.16.1, the Vala compiler
 * generated from transport.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */
/*===========================================================================*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define FSO_FRAMEWORK_TYPE_TRANSPORT_STATE (fso_framework_transport_state_get_type ())

#define FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC (fso_framework_transport_spec_get_type ())
#define FSO_FRAMEWORK_TRANSPORT_SPEC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC, FsoFrameworkTransportSpec))
#define FSO_FRAMEWORK_TRANSPORT_SPEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC, FsoFrameworkTransportSpecClass))
#define FSO_FRAMEWORK_IS_TRANSPORT_SPEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC))
#define FSO_FRAMEWORK_IS_TRANSPORT_SPEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC))
#define FSO_FRAMEWORK_TRANSPORT_SPEC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC, FsoFrameworkTransportSpecClass))

typedef struct _FsoFrameworkTransportSpec FsoFrameworkTransportSpec;
typedef struct _FsoFrameworkTransportSpecClass FsoFrameworkTransportSpecClass;
typedef struct _FsoFrameworkTransportSpecPrivate FsoFrameworkTransportSpecPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define FSO_FRAMEWORK_TYPE_TRANSPORT (fso_framework_transport_get_type ())
#define FSO_FRAMEWORK_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT, FsoFrameworkTransport))
#define FSO_FRAMEWORK_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_TRANSPORT, FsoFrameworkTransportClass))
#define FSO_FRAMEWORK_IS_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT))
#define FSO_FRAMEWORK_IS_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_TRANSPORT))
#define FSO_FRAMEWORK_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_TRANSPORT, FsoFrameworkTransportClass))

typedef struct _FsoFrameworkTransport FsoFrameworkTransport;
typedef struct _FsoFrameworkTransportClass FsoFrameworkTransportClass;

#define FSO_FRAMEWORK_TYPE_BASE_TRANSPORT (fso_framework_base_transport_get_type ())
#define FSO_FRAMEWORK_BASE_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_BASE_TRANSPORT, FsoFrameworkBaseTransport))
#define FSO_FRAMEWORK_BASE_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_BASE_TRANSPORT, FsoFrameworkBaseTransportClass))
#define FSO_FRAMEWORK_IS_BASE_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_BASE_TRANSPORT))
#define FSO_FRAMEWORK_IS_BASE_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_BASE_TRANSPORT))
#define FSO_FRAMEWORK_BASE_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_BASE_TRANSPORT, FsoFrameworkBaseTransportClass))

typedef struct _FsoFrameworkBaseTransport FsoFrameworkBaseTransport;
typedef struct _FsoFrameworkBaseTransportClass FsoFrameworkBaseTransportClass;

#define FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT (fso_framework_serial_transport_get_type ())
#define FSO_FRAMEWORK_SERIAL_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT, FsoFrameworkSerialTransport))
#define FSO_FRAMEWORK_SERIAL_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT, FsoFrameworkSerialTransportClass))
#define FSO_FRAMEWORK_IS_SERIAL_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT))
#define FSO_FRAMEWORK_IS_SERIAL_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT))
#define FSO_FRAMEWORK_SERIAL_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_SERIAL_TRANSPORT, FsoFrameworkSerialTransportClass))

typedef struct _FsoFrameworkSerialTransport FsoFrameworkSerialTransport;
typedef struct _FsoFrameworkSerialTransportClass FsoFrameworkSerialTransportClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FSO_FRAMEWORK_TYPE_PTY_TRANSPORT (fso_framework_pty_transport_get_type ())
#define FSO_FRAMEWORK_PTY_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_PTY_TRANSPORT, FsoFrameworkPtyTransport))
#define FSO_FRAMEWORK_PTY_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_PTY_TRANSPORT, FsoFrameworkPtyTransportClass))
#define FSO_FRAMEWORK_IS_PTY_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_PTY_TRANSPORT))
#define FSO_FRAMEWORK_IS_PTY_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_PTY_TRANSPORT))
#define FSO_FRAMEWORK_PTY_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_PTY_TRANSPORT, FsoFrameworkPtyTransportClass))

typedef struct _FsoFrameworkPtyTransport FsoFrameworkPtyTransport;
typedef struct _FsoFrameworkPtyTransportClass FsoFrameworkPtyTransportClass;

#define FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT (fso_framework_socket_transport_get_type ())
#define FSO_FRAMEWORK_SOCKET_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT, FsoFrameworkSocketTransport))
#define FSO_FRAMEWORK_SOCKET_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT, FsoFrameworkSocketTransportClass))
#define FSO_FRAMEWORK_IS_SOCKET_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT))
#define FSO_FRAMEWORK_IS_SOCKET_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT))
#define FSO_FRAMEWORK_SOCKET_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_SOCKET_TRANSPORT, FsoFrameworkSocketTransportClass))

typedef struct _FsoFrameworkSocketTransport FsoFrameworkSocketTransport;
typedef struct _FsoFrameworkSocketTransportClass FsoFrameworkSocketTransportClass;

#define FSO_FRAMEWORK_TYPE_NULL_TRANSPORT (fso_framework_null_transport_get_type ())
#define FSO_FRAMEWORK_NULL_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_NULL_TRANSPORT, FsoFrameworkNullTransport))
#define FSO_FRAMEWORK_NULL_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_NULL_TRANSPORT, FsoFrameworkNullTransportClass))
#define FSO_FRAMEWORK_IS_NULL_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_NULL_TRANSPORT))
#define FSO_FRAMEWORK_IS_NULL_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_NULL_TRANSPORT))
#define FSO_FRAMEWORK_NULL_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_NULL_TRANSPORT, FsoFrameworkNullTransportClass))

typedef struct _FsoFrameworkNullTransport FsoFrameworkNullTransport;
typedef struct _FsoFrameworkNullTransportClass FsoFrameworkNullTransportClass;

#define FSO_FRAMEWORK_TYPE_RAW_TRANSPORT (fso_framework_raw_transport_get_type ())
#define FSO_FRAMEWORK_RAW_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_RAW_TRANSPORT, FsoFrameworkRawTransport))
#define FSO_FRAMEWORK_RAW_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_RAW_TRANSPORT, FsoFrameworkRawTransportClass))
#define FSO_FRAMEWORK_IS_RAW_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_RAW_TRANSPORT))
#define FSO_FRAMEWORK_IS_RAW_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_RAW_TRANSPORT))
#define FSO_FRAMEWORK_RAW_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_RAW_TRANSPORT, FsoFrameworkRawTransportClass))

typedef struct _FsoFrameworkRawTransport FsoFrameworkRawTransport;
typedef struct _FsoFrameworkRawTransportClass FsoFrameworkRawTransportClass;

#define FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT (fso_framework_combined_transport_get_type ())
#define FSO_FRAMEWORK_COMBINED_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT, FsoFrameworkCombinedTransport))
#define FSO_FRAMEWORK_COMBINED_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT, FsoFrameworkCombinedTransportClass))
#define FSO_FRAMEWORK_IS_COMBINED_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT))
#define FSO_FRAMEWORK_IS_COMBINED_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT))
#define FSO_FRAMEWORK_COMBINED_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_COMBINED_TRANSPORT, FsoFrameworkCombinedTransportClass))

typedef struct _FsoFrameworkCombinedTransport FsoFrameworkCombinedTransport;
typedef struct _FsoFrameworkCombinedTransportClass FsoFrameworkCombinedTransportClass;

#define FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT (fso_framework_ngsm_transport_get_type ())
#define FSO_FRAMEWORK_NGSM_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT, FsoFrameworkNgsmTransport))
#define FSO_FRAMEWORK_NGSM_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT, FsoFrameworkNgsmTransportClass))
#define FSO_FRAMEWORK_IS_NGSM_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT))
#define FSO_FRAMEWORK_IS_NGSM_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT))
#define FSO_FRAMEWORK_NGSM_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_NGSM_TRANSPORT, FsoFrameworkNgsmTransportClass))

typedef struct _FsoFrameworkNgsmTransport FsoFrameworkNgsmTransport;
typedef struct _FsoFrameworkNgsmTransportClass FsoFrameworkNgsmTransportClass;

#define FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT (fso_framework_ngsm_basic_mux_transport_get_type ())
#define FSO_FRAMEWORK_NGSM_BASIC_MUX_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT, FsoFrameworkNgsmBasicMuxTransport))
#define FSO_FRAMEWORK_NGSM_BASIC_MUX_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT, FsoFrameworkNgsmBasicMuxTransportClass))
#define FSO_FRAMEWORK_IS_NGSM_BASIC_MUX_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT))
#define FSO_FRAMEWORK_IS_NGSM_BASIC_MUX_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT))
#define FSO_FRAMEWORK_NGSM_BASIC_MUX_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_NGSM_BASIC_MUX_TRANSPORT, FsoFrameworkNgsmBasicMuxTransportClass))

typedef struct _FsoFrameworkNgsmBasicMuxTransport FsoFrameworkNgsmBasicMuxTransport;
typedef struct _FsoFrameworkNgsmBasicMuxTransportClass FsoFrameworkNgsmBasicMuxTransportClass;

#define FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT (fso_framework_ngsm_advanced_mux_transport_get_type ())
#define FSO_FRAMEWORK_NGSM_ADVANCED_MUX_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT, FsoFrameworkNgsmAdvancedMuxTransport))
#define FSO_FRAMEWORK_NGSM_ADVANCED_MUX_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT, FsoFrameworkNgsmAdvancedMuxTransportClass))
#define FSO_FRAMEWORK_IS_NGSM_ADVANCED_MUX_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT))
#define FSO_FRAMEWORK_IS_NGSM_ADVANCED_MUX_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT))
#define FSO_FRAMEWORK_NGSM_ADVANCED_MUX_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_NGSM_ADVANCED_MUX_TRANSPORT, FsoFrameworkNgsmAdvancedMuxTransportClass))

typedef struct _FsoFrameworkNgsmAdvancedMuxTransport FsoFrameworkNgsmAdvancedMuxTransport;
typedef struct _FsoFrameworkNgsmAdvancedMuxTransportClass FsoFrameworkNgsmAdvancedMuxTransportClass;
typedef struct _FsoFrameworkParamSpecTransportSpec FsoFrameworkParamSpecTransportSpec;
typedef struct _FsoFrameworkTransportPrivate FsoFrameworkTransportPrivate;

typedef enum  {
	FSO_FRAMEWORK_TRANSPORT_ERROR_UNABLE_TO_OPEN,
	FSO_FRAMEWORK_TRANSPORT_ERROR_UNABLE_TO_WRITE
} FsoFrameworkTransportError;
#define FSO_FRAMEWORK_TRANSPORT_ERROR fso_framework_transport_error_quark ()
typedef enum  {
	FSO_FRAMEWORK_TRANSPORT_STATE_CLOSED,
	FSO_FRAMEWORK_TRANSPORT_STATE_OPEN,
	FSO_FRAMEWORK_TRANSPORT_STATE_ALIVE,
	FSO_FRAMEWORK_TRANSPORT_STATE_FROZEN,
	FSO_FRAMEWORK_TRANSPORT_STATE_DEAD
} FsoFrameworkTransportState;

struct _FsoFrameworkTransportSpec {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FsoFrameworkTransportSpecPrivate * priv;
	gchar* type;
	gchar* name;
	guint speed;
	gboolean raw;
	gboolean hard;
};

struct _FsoFrameworkTransportSpecClass {
	GTypeClass parent_class;
	void (*finalize) (FsoFrameworkTransportSpec *self);
};

struct _FsoFrameworkParamSpecTransportSpec {
	GParamSpec parent_instance;
};

typedef void (*FsoFrameworkTransportFunc) (FsoFrameworkTransport* transport, void* user_data);
struct _FsoFrameworkTransport {
	GObject parent_instance;
	FsoFrameworkTransportPrivate * priv;
	FsoFrameworkLogger* logger;
};

struct _FsoFrameworkTransportClass {
	GObjectClass parent_class;
	gboolean (*isOpen) (FsoFrameworkTransport* self);
	void (*openAsync) (FsoFrameworkTransport* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	gboolean (*openAsync_finish) (FsoFrameworkTransport* self, GAsyncResult* _res_);
	gboolean (*open) (FsoFrameworkTransport* self);
	void (*close) (FsoFrameworkTransport* self);
	gchar* (*getName) (FsoFrameworkTransport* self);
	void (*setDelegates) (FsoFrameworkTransport* self, FsoFrameworkTransportFunc readfunc, void* readfunc_target, FsoFrameworkTransportFunc hupfunc, void* hupfunc_target);
	void (*getDelegates) (FsoFrameworkTransport* self, FsoFrameworkTransportFunc* readfun, void** readfun_target, GDestroyNotify* readfun_target_destroy_notify, FsoFrameworkTransportFunc* hupfun, void** hupfun_target, GDestroyNotify* hupfun_target_destroy_notify);
	void (*setPriorities) (FsoFrameworkTransport* self, gint rp, gint wp);
	void (*setBuffered) (FsoFrameworkTransport* self, gboolean on);
	gint (*writeAndRead) (FsoFrameworkTransport* self, void* wdata, gint wlength, void* rdata, gint rlength, gint maxWait);
	gint (*read) (FsoFrameworkTransport* self, void* data, gint length);
	gint (*write) (FsoFrameworkTransport* self, void* data, gint length);
	gint (*freeze) (FsoFrameworkTransport* self);
	void (*thaw) (FsoFrameworkTransport* self);
	void (*drain) (FsoFrameworkTransport* self);
	void (*flush) (FsoFrameworkTransport* self);
	gboolean (*suspend) (FsoFrameworkTransport* self);
	void (*resume) (FsoFrameworkTransport* self);
};

typedef gint (*FsoFrameworkTransportDataFunc) (void* data, gint length, FsoFrameworkTransport* transport, void* user_data);
typedef gboolean (*FsoFrameworkTransportBoolFunc) (FsoFrameworkTransport* transport, void* user_data);
typedef gint (*FsoFrameworkTransportIntFunc) (FsoFrameworkTransport* transport, void* user_data);

static gpointer fso_framework_transport_spec_parent_class = NULL;
static gpointer fso_framework_transport_parent_class = NULL;

GQuark fso_framework_transport_error_quark (void);
GType fso_framework_transport_state_get_type (void) G_GNUC_CONST;
gpointer fso_framework_transport_spec_ref (gpointer instance);
void fso_framework_transport_spec_unref (gpointer instance);
GParamSpec* fso_framework_param_spec_transport_spec (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void fso_framework_value_set_transport_spec (GValue* value, gpointer v_object);
void fso_framework_value_take_transport_spec (GValue* value, gpointer v_object);
gpointer fso_framework_value_get_transport_spec (const GValue* value);
GType fso_framework_transport_spec_get_type (void) G_GNUC_CONST;
enum  {
	FSO_FRAMEWORK_TRANSPORT_SPEC_DUMMY_PROPERTY
};
FsoFrameworkTransportSpec* fso_framework_transport_spec_new (const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard);
FsoFrameworkTransportSpec* fso_framework_transport_spec_construct (GType object_type, const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard);
gchar* fso_framework_transport_spec_repr (FsoFrameworkTransportSpec* self);
FsoFrameworkTransportSpec* fso_framework_transport_spec_parse (const gchar* line);
static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value);
GType fso_framework_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkTransport* fso_framework_transport_spec_create (FsoFrameworkTransportSpec* self);
FsoFrameworkSerialTransport* fso_framework_serial_transport_new (const gchar* portname, guint portspeed, gboolean raw, gboolean hard);
FsoFrameworkSerialTransport* fso_framework_serial_transport_construct (GType object_type, const gchar* portname, guint portspeed, gboolean raw, gboolean hard);
GType fso_framework_base_transport_get_type (void) G_GNUC_CONST;
GType fso_framework_serial_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkPtyTransport* fso_framework_pty_transport_new (void);
FsoFrameworkPtyTransport* fso_framework_pty_transport_construct (GType object_type);
GType fso_framework_pty_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkSocketTransport* fso_framework_socket_transport_new (const gchar* type, const gchar* host, guint port);
FsoFrameworkSocketTransport* fso_framework_socket_transport_construct (GType object_type, const gchar* type, const gchar* host, guint port);
GType fso_framework_socket_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkNullTransport* fso_framework_null_transport_new (const gchar* name, guint speed, gboolean raw, gboolean hard);
FsoFrameworkNullTransport* fso_framework_null_transport_construct (GType object_type, const gchar* name, guint speed, gboolean raw, gboolean hard);
GType fso_framework_null_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkRawTransport* fso_framework_raw_transport_new (const gchar* portname);
FsoFrameworkRawTransport* fso_framework_raw_transport_construct (GType object_type, const gchar* portname);
GType fso_framework_raw_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkCombinedTransport* fso_framework_combined_transport_new (const gchar* specification);
FsoFrameworkCombinedTransport* fso_framework_combined_transport_construct (GType object_type, const gchar* specification);
GType fso_framework_combined_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkNgsmBasicMuxTransport* fso_framework_ngsm_basic_mux_transport_new (const gchar* portname, guint portspeed, guint framesize);
FsoFrameworkNgsmBasicMuxTransport* fso_framework_ngsm_basic_mux_transport_construct (GType object_type, const gchar* portname, guint portspeed, guint framesize);
GType fso_framework_ngsm_transport_get_type (void) G_GNUC_CONST;
GType fso_framework_ngsm_basic_mux_transport_get_type (void) G_GNUC_CONST;
FsoFrameworkNgsmAdvancedMuxTransport* fso_framework_ngsm_advanced_mux_transport_new (const gchar* portname, guint portspeed, guint framesize);
FsoFrameworkNgsmAdvancedMuxTransport* fso_framework_ngsm_advanced_mux_transport_construct (GType object_type, const gchar* portname, guint portspeed, guint framesize);
GType fso_framework_ngsm_advanced_mux_transport_get_type (void) G_GNUC_CONST;
static void fso_framework_transport_spec_finalize (FsoFrameworkTransportSpec* obj);
enum  {
	FSO_FRAMEWORK_TRANSPORT_DUMMY_PROPERTY
};
FsoFrameworkTransport* fso_framework_transport_create (const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard);
gboolean fso_framework_transport_isOpen (FsoFrameworkTransport* self);
static gboolean fso_framework_transport_real_isOpen (FsoFrameworkTransport* self);
void fso_framework_transport_openAsync (FsoFrameworkTransport* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean fso_framework_transport_openAsync_finish (FsoFrameworkTransport* self, GAsyncResult* _res_);
gboolean fso_framework_transport_open (FsoFrameworkTransport* self);
static gboolean fso_framework_transport_real_open (FsoFrameworkTransport* self);
void fso_framework_transport_close (FsoFrameworkTransport* self);
static void fso_framework_transport_real_close (FsoFrameworkTransport* self);
gchar* fso_framework_transport_getName (FsoFrameworkTransport* self);
static gchar* fso_framework_transport_real_getName (FsoFrameworkTransport* self);
void fso_framework_transport_setDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc readfunc, void* readfunc_target, FsoFrameworkTransportFunc hupfunc, void* hupfunc_target);
static void fso_framework_transport_real_setDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc readfunc, void* readfunc_target, FsoFrameworkTransportFunc hupfunc, void* hupfunc_target);
void fso_framework_transport_getDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc* readfun, void** readfun_target, GDestroyNotify* readfun_target_destroy_notify, FsoFrameworkTransportFunc* hupfun, void** hupfun_target, GDestroyNotify* hupfun_target_destroy_notify);
static void fso_framework_transport_real_getDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc* readfun, void** readfun_target, GDestroyNotify* readfun_target_destroy_notify, FsoFrameworkTransportFunc* hupfun, void** hupfun_target, GDestroyNotify* hupfun_target_destroy_notify);
void fso_framework_transport_setPriorities (FsoFrameworkTransport* self, gint rp, gint wp);
static void fso_framework_transport_real_setPriorities (FsoFrameworkTransport* self, gint rp, gint wp);
void fso_framework_transport_setBuffered (FsoFrameworkTransport* self, gboolean on);
static void fso_framework_transport_real_setBuffered (FsoFrameworkTransport* self, gboolean on);
gint fso_framework_transport_writeAndRead (FsoFrameworkTransport* self, void* wdata, gint wlength, void* rdata, gint rlength, gint maxWait);
static gint fso_framework_transport_real_writeAndRead (FsoFrameworkTransport* self, void* wdata, gint wlength, void* rdata, gint rlength, gint maxWait);
gint fso_framework_transport_read (FsoFrameworkTransport* self, void* data, gint length);
static gint fso_framework_transport_real_read (FsoFrameworkTransport* self, void* data, gint length);
gint fso_framework_transport_write (FsoFrameworkTransport* self, void* data, gint length);
static gint fso_framework_transport_real_write (FsoFrameworkTransport* self, void* data, gint length);
gint fso_framework_transport_freeze (FsoFrameworkTransport* self);
static gint fso_framework_transport_real_freeze (FsoFrameworkTransport* self);
void fso_framework_transport_thaw (FsoFrameworkTransport* self);
static void fso_framework_transport_real_thaw (FsoFrameworkTransport* self);
void fso_framework_transport_drain (FsoFrameworkTransport* self);
static void fso_framework_transport_real_drain (FsoFrameworkTransport* self);
void fso_framework_transport_flush (FsoFrameworkTransport* self);
static void fso_framework_transport_real_flush (FsoFrameworkTransport* self);
gboolean fso_framework_transport_suspend (FsoFrameworkTransport* self);
static gboolean fso_framework_transport_real_suspend (FsoFrameworkTransport* self);
void fso_framework_transport_resume (FsoFrameworkTransport* self);
static void fso_framework_transport_real_resume (FsoFrameworkTransport* self);
FsoFrameworkTransport* fso_framework_transport_construct (GType object_type);
static void fso_framework_transport_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GQuark fso_framework_transport_error_quark (void) {
	return g_quark_from_static_string ("fso_framework_transport_error-quark");
}


GType fso_framework_transport_state_get_type (void) {
	static volatile gsize fso_framework_transport_state_type_id__volatile = 0;
	if (g_once_init_enter (&fso_framework_transport_state_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_FRAMEWORK_TRANSPORT_STATE_CLOSED, "FSO_FRAMEWORK_TRANSPORT_STATE_CLOSED", "closed"}, {FSO_FRAMEWORK_TRANSPORT_STATE_OPEN, "FSO_FRAMEWORK_TRANSPORT_STATE_OPEN", "open"}, {FSO_FRAMEWORK_TRANSPORT_STATE_ALIVE, "FSO_FRAMEWORK_TRANSPORT_STATE_ALIVE", "alive"}, {FSO_FRAMEWORK_TRANSPORT_STATE_FROZEN, "FSO_FRAMEWORK_TRANSPORT_STATE_FROZEN", "frozen"}, {FSO_FRAMEWORK_TRANSPORT_STATE_DEAD, "FSO_FRAMEWORK_TRANSPORT_STATE_DEAD", "dead"}, {0, NULL, NULL}};
		GType fso_framework_transport_state_type_id;
		fso_framework_transport_state_type_id = g_enum_register_static ("FsoFrameworkTransportState", values);
		g_once_init_leave (&fso_framework_transport_state_type_id__volatile, fso_framework_transport_state_type_id);
	}
	return fso_framework_transport_state_type_id__volatile;
}


FsoFrameworkTransportSpec* fso_framework_transport_spec_construct (GType object_type, const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard) {
	FsoFrameworkTransportSpec* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	guint _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	g_return_val_if_fail (type != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	self = (FsoFrameworkTransportSpec*) g_type_create_instance (object_type);
	_tmp0_ = type;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->type);
	self->type = _tmp1_;
	_tmp2_ = name;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->name);
	self->name = _tmp3_;
	_tmp4_ = speed;
	self->speed = _tmp4_;
	_tmp5_ = raw;
	self->raw = _tmp5_;
	_tmp6_ = hard;
	self->hard = _tmp6_;
	return self;
}


FsoFrameworkTransportSpec* fso_framework_transport_spec_new (const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard) {
	return fso_framework_transport_spec_construct (FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC, type, name, speed, raw, hard);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* fso_framework_transport_spec_repr (FsoFrameworkTransportSpec* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_;
	const gchar* _tmp3_ = NULL;
	guint _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->type;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = self->name;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = self->speed;
	_tmp5_ = g_strdup_printf ("%u", _tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strconcat (_tmp1_, ":", _tmp3_, ":", _tmp6_, NULL);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	result = _tmp8_;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


FsoFrameworkTransportSpec* fso_framework_transport_spec_parse (const gchar* line) {
	FsoFrameworkTransportSpec* result = NULL;
	gchar** _tmp0_ = NULL;
	gchar** tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gchar* _tmp1_;
	gchar* current_token;
	gint depth;
	gchar* _tmp2_;
	gchar* type;
	gchar* _tmp3_;
	gchar* name;
	gint speed;
	const gchar* _tmp36_;
	gint _tmp37_;
	gint _tmp38_;
	gchar** _tmp42_;
	gint _tmp42__length1;
	const gchar* _tmp59_;
	const gchar* _tmp60_;
	gint _tmp61_;
	FsoFrameworkTransportSpec* _tmp62_;
	g_return_val_if_fail (line != NULL, NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	tokens = _tmp0_;
	tokens_length1 = 0;
	_tokens_size_ = tokens_length1;
	_tmp1_ = g_strdup ("");
	current_token = _tmp1_;
	depth = 0;
	_tmp2_ = g_strdup ("");
	type = _tmp2_;
	_tmp3_ = g_strdup ("");
	name = _tmp3_;
	speed = 0;
	{
		gint n;
		n = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				const gchar* _tmp8_;
				gint _tmp9_;
				gint _tmp10_;
				gboolean _tmp11_ = FALSE;
				const gchar* _tmp12_;
				gint _tmp13_;
				gchar _tmp14_ = '\0';
				gboolean _tmp16_;
				const gchar* _tmp21_;
				gint _tmp22_;
				gchar _tmp23_ = '\0';
				const gchar* _tmp29_;
				const gchar* _tmp30_;
				gint _tmp31_;
				gchar _tmp32_ = '\0';
				gchar* _tmp33_ = NULL;
				gchar* _tmp34_;
				gchar* _tmp35_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = n;
					n = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = n;
				_tmp8_ = line;
				_tmp9_ = strlen (_tmp8_);
				_tmp10_ = _tmp9_;
				if (!(_tmp7_ < _tmp10_)) {
					break;
				}
				_tmp12_ = line;
				_tmp13_ = n;
				_tmp14_ = string_get (_tmp12_, (glong) _tmp13_);
				if (_tmp14_ == ':') {
					gint _tmp15_;
					_tmp15_ = depth;
					_tmp11_ = _tmp15_ == 0;
				} else {
					_tmp11_ = FALSE;
				}
				_tmp16_ = _tmp11_;
				if (_tmp16_) {
					gchar** _tmp17_;
					gint _tmp17__length1;
					const gchar* _tmp18_;
					gchar* _tmp19_;
					gchar* _tmp20_;
					_tmp17_ = tokens;
					_tmp17__length1 = tokens_length1;
					_tmp18_ = current_token;
					_tmp19_ = g_strdup (_tmp18_);
					_vala_array_add4 (&tokens, &tokens_length1, &_tokens_size_, _tmp19_);
					_tmp20_ = g_strdup ("");
					_g_free0 (current_token);
					current_token = _tmp20_;
					continue;
				}
				_tmp21_ = line;
				_tmp22_ = n;
				_tmp23_ = string_get (_tmp21_, (glong) _tmp22_);
				if (_tmp23_ == '[') {
					gint _tmp24_;
					_tmp24_ = depth;
					depth = _tmp24_ + 1;
					continue;
				} else {
					const gchar* _tmp25_;
					gint _tmp26_;
					gchar _tmp27_ = '\0';
					_tmp25_ = line;
					_tmp26_ = n;
					_tmp27_ = string_get (_tmp25_, (glong) _tmp26_);
					if (_tmp27_ == ']') {
						gint _tmp28_;
						_tmp28_ = depth;
						depth = _tmp28_ - 1;
						continue;
					}
				}
				_tmp29_ = current_token;
				_tmp30_ = line;
				_tmp31_ = n;
				_tmp32_ = string_get (_tmp30_, (glong) _tmp31_);
				_tmp33_ = g_strdup_printf ("%c", _tmp32_);
				_tmp34_ = _tmp33_;
				_tmp35_ = g_strconcat (_tmp29_, _tmp34_, NULL);
				_g_free0 (current_token);
				current_token = _tmp35_;
				_g_free0 (_tmp34_);
			}
		}
	}
	_tmp36_ = current_token;
	_tmp37_ = strlen (_tmp36_);
	_tmp38_ = _tmp37_;
	if (_tmp38_ > 0) {
		gchar** _tmp39_;
		gint _tmp39__length1;
		const gchar* _tmp40_;
		gchar* _tmp41_;
		_tmp39_ = tokens;
		_tmp39__length1 = tokens_length1;
		_tmp40_ = current_token;
		_tmp41_ = g_strdup (_tmp40_);
		_vala_array_add5 (&tokens, &tokens_length1, &_tokens_size_, _tmp41_);
	}
	_tmp42_ = tokens;
	_tmp42__length1 = tokens_length1;
	if (_tmp42__length1 == 3) {
		gchar** _tmp43_;
		gint _tmp43__length1;
		const gchar* _tmp44_;
		gchar* _tmp45_;
		gchar** _tmp46_;
		gint _tmp46__length1;
		const gchar* _tmp47_;
		gchar* _tmp48_;
		gchar** _tmp49_;
		gint _tmp49__length1;
		const gchar* _tmp50_;
		gint _tmp51_ = 0;
		_tmp43_ = tokens;
		_tmp43__length1 = tokens_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_strdup (_tmp44_);
		_g_free0 (type);
		type = _tmp45_;
		_tmp46_ = tokens;
		_tmp46__length1 = tokens_length1;
		_tmp47_ = _tmp46_[1];
		_tmp48_ = g_strdup (_tmp47_);
		_g_free0 (name);
		name = _tmp48_;
		_tmp49_ = tokens;
		_tmp49__length1 = tokens_length1;
		_tmp50_ = _tmp49_[2];
		_tmp51_ = atoi (_tmp50_);
		speed = _tmp51_;
	} else {
		gchar** _tmp52_;
		gint _tmp52__length1;
		_tmp52_ = tokens;
		_tmp52__length1 = tokens_length1;
		if (_tmp52__length1 == 2) {
			gchar** _tmp53_;
			gint _tmp53__length1;
			const gchar* _tmp54_;
			gchar* _tmp55_;
			gchar** _tmp56_;
			gint _tmp56__length1;
			const gchar* _tmp57_;
			gchar* _tmp58_;
			_tmp53_ = tokens;
			_tmp53__length1 = tokens_length1;
			_tmp54_ = _tmp53_[0];
			_tmp55_ = g_strdup (_tmp54_);
			_g_free0 (type);
			type = _tmp55_;
			_tmp56_ = tokens;
			_tmp56__length1 = tokens_length1;
			_tmp57_ = _tmp56_[1];
			_tmp58_ = g_strdup (_tmp57_);
			_g_free0 (name);
			name = _tmp58_;
		}
	}
	_tmp59_ = type;
	_tmp60_ = name;
	_tmp61_ = speed;
	_tmp62_ = fso_framework_transport_spec_new (_tmp59_, _tmp60_, (guint) _tmp61_, TRUE, TRUE);
	result = _tmp62_;
	_g_free0 (name);
	_g_free0 (type);
	_g_free0 (current_token);
	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


FsoFrameworkTransport* fso_framework_transport_spec_create (FsoFrameworkTransportSpec* self) {
	FsoFrameworkTransport* result = NULL;
	FsoFrameworkTransport* transport;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	static GQuark _tmp2_label3 = 0;
	static GQuark _tmp2_label4 = 0;
	static GQuark _tmp2_label5 = 0;
	static GQuark _tmp2_label6 = 0;
	static GQuark _tmp2_label7 = 0;
	static GQuark _tmp2_label8 = 0;
	static GQuark _tmp2_label9 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	transport = NULL;
	_tmp0_ = self->type;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("serial")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp4_;
				guint _tmp5_;
				gboolean _tmp6_;
				gboolean _tmp7_;
				FsoFrameworkSerialTransport* _tmp8_;
				_tmp4_ = self->name;
				_tmp5_ = self->speed;
				_tmp6_ = self->raw;
				_tmp7_ = self->hard;
				_tmp8_ = fso_framework_serial_transport_new (_tmp4_, _tmp5_, _tmp6_, _tmp7_);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp8_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("pty")))) {
		switch (0) {
			default:
			{
				FsoFrameworkPtyTransport* _tmp9_;
				_tmp9_ = fso_framework_pty_transport_new ();
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp9_;
				break;
			}
		}
	} else if (((_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("unix")))) || (_tmp3_ == ((0 != _tmp2_label3) ? _tmp2_label3 : (_tmp2_label3 = g_quark_from_static_string ("udp"))))) || (_tmp3_ == ((0 != _tmp2_label4) ? _tmp2_label4 : (_tmp2_label4 = g_quark_from_static_string ("tcp"))))) {
		switch (0) {
			default:
			{
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				guint _tmp12_;
				FsoFrameworkSocketTransport* _tmp13_;
				_tmp10_ = self->type;
				_tmp11_ = self->name;
				_tmp12_ = self->speed;
				_tmp13_ = fso_framework_socket_transport_new (_tmp10_, _tmp11_, _tmp12_);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp13_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label5) ? _tmp2_label5 : (_tmp2_label5 = g_quark_from_static_string ("null")))) {
		switch (0) {
			default:
			{
				FsoFrameworkNullTransport* _tmp14_;
				_tmp14_ = fso_framework_null_transport_new ("null", (guint) 0, TRUE, TRUE);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp14_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label6) ? _tmp2_label6 : (_tmp2_label6 = g_quark_from_static_string ("raw")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp15_;
				FsoFrameworkRawTransport* _tmp16_;
				_tmp15_ = self->name;
				_tmp16_ = fso_framework_raw_transport_new (_tmp15_);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp16_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label7) ? _tmp2_label7 : (_tmp2_label7 = g_quark_from_static_string ("combined")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp17_;
				FsoFrameworkCombinedTransport* _tmp18_;
				_tmp17_ = self->name;
				_tmp18_ = fso_framework_combined_transport_new (_tmp17_);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp18_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label8) ? _tmp2_label8 : (_tmp2_label8 = g_quark_from_static_string ("ngsm-basic")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp19_;
				guint _tmp20_;
				FsoFrameworkNgsmBasicMuxTransport* _tmp21_;
				_tmp19_ = self->name;
				_tmp20_ = self->speed;
				_tmp21_ = fso_framework_ngsm_basic_mux_transport_new (_tmp19_, _tmp20_, (guint) 64);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp21_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label9) ? _tmp2_label9 : (_tmp2_label9 = g_quark_from_static_string ("ngsm-advanced")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp22_;
				guint _tmp23_;
				FsoFrameworkNgsmAdvancedMuxTransport* _tmp24_;
				_tmp22_ = self->name;
				_tmp23_ = self->speed;
				_tmp24_ = fso_framework_ngsm_advanced_mux_transport_new (_tmp22_, _tmp23_, (guint) 64);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp24_;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				FsoFrameworkLogger* _tmp25_;
				const gchar* _tmp26_;
				const gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				gchar* _tmp29_;
				FsoFrameworkNullTransport* _tmp30_;
				_tmp25_ = fso_framework_theLogger;
				_tmp26_ = self->type;
				_tmp27_ = string_to_string (_tmp26_);
				_tmp28_ = g_strconcat ("Invalid transport type ", _tmp27_, ". Using NullTransport", NULL);
				_tmp29_ = _tmp28_;
				fso_framework_logger_warning (_tmp25_, _tmp29_);
				_g_free0 (_tmp29_);
				_tmp30_ = fso_framework_null_transport_new ("null", (guint) 0, TRUE, TRUE);
				_g_object_unref0 (transport);
				transport = (FsoFrameworkTransport*) _tmp30_;
				break;
			}
		}
	}
	result = transport;
	return result;
}


static void fso_framework_value_transport_spec_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void fso_framework_value_transport_spec_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		fso_framework_transport_spec_unref (value->data[0].v_pointer);
	}
}


static void fso_framework_value_transport_spec_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = fso_framework_transport_spec_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer fso_framework_value_transport_spec_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* fso_framework_value_transport_spec_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		FsoFrameworkTransportSpec* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = fso_framework_transport_spec_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* fso_framework_value_transport_spec_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	FsoFrameworkTransportSpec** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = fso_framework_transport_spec_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* fso_framework_param_spec_transport_spec (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	FsoFrameworkParamSpecTransportSpec* spec;
	g_return_val_if_fail (g_type_is_a (object_type, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer fso_framework_value_get_transport_spec (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC), NULL);
	return value->data[0].v_pointer;
}


void fso_framework_value_set_transport_spec (GValue* value, gpointer v_object) {
	FsoFrameworkTransportSpec* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		fso_framework_transport_spec_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		fso_framework_transport_spec_unref (old);
	}
}


void fso_framework_value_take_transport_spec (GValue* value, gpointer v_object) {
	FsoFrameworkTransportSpec* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, FSO_FRAMEWORK_TYPE_TRANSPORT_SPEC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		fso_framework_transport_spec_unref (old);
	}
}


static void fso_framework_transport_spec_class_init (FsoFrameworkTransportSpecClass * klass) {
	fso_framework_transport_spec_parent_class = g_type_class_peek_parent (klass);
	FSO_FRAMEWORK_TRANSPORT_SPEC_CLASS (klass)->finalize = fso_framework_transport_spec_finalize;
}


static void fso_framework_transport_spec_instance_init (FsoFrameworkTransportSpec * self) {
	self->ref_count = 1;
}


static void fso_framework_transport_spec_finalize (FsoFrameworkTransportSpec* obj) {
	FsoFrameworkTransportSpec * self;
	self = FSO_FRAMEWORK_TRANSPORT_SPEC (obj);
	_g_free0 (self->type);
	_g_free0 (self->name);
}


GType fso_framework_transport_spec_get_type (void) {
	static volatile gsize fso_framework_transport_spec_type_id__volatile = 0;
	if (g_once_init_enter (&fso_framework_transport_spec_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { fso_framework_value_transport_spec_init, fso_framework_value_transport_spec_free_value, fso_framework_value_transport_spec_copy_value, fso_framework_value_transport_spec_peek_pointer, "p", fso_framework_value_transport_spec_collect_value, "p", fso_framework_value_transport_spec_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FsoFrameworkTransportSpecClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_framework_transport_spec_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoFrameworkTransportSpec), 0, (GInstanceInitFunc) fso_framework_transport_spec_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType fso_framework_transport_spec_type_id;
		fso_framework_transport_spec_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FsoFrameworkTransportSpec", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&fso_framework_transport_spec_type_id__volatile, fso_framework_transport_spec_type_id);
	}
	return fso_framework_transport_spec_type_id__volatile;
}


gpointer fso_framework_transport_spec_ref (gpointer instance) {
	FsoFrameworkTransportSpec* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void fso_framework_transport_spec_unref (gpointer instance) {
	FsoFrameworkTransportSpec* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FSO_FRAMEWORK_TRANSPORT_SPEC_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


/**
     * Create @a FsoFramework.Transport as indicated by @a type
     **/
FsoFrameworkTransport* fso_framework_transport_create (const gchar* type, const gchar* name, guint speed, gboolean raw, gboolean hard) {
	FsoFrameworkTransport* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	static GQuark _tmp2_label3 = 0;
	static GQuark _tmp2_label4 = 0;
	static GQuark _tmp2_label5 = 0;
	static GQuark _tmp2_label6 = 0;
	static GQuark _tmp2_label7 = 0;
	g_return_val_if_fail (type != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = type;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("serial")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp4_;
				guint _tmp5_;
				gboolean _tmp6_;
				gboolean _tmp7_;
				FsoFrameworkSerialTransport* _tmp8_;
				_tmp4_ = name;
				_tmp5_ = speed;
				_tmp6_ = raw;
				_tmp7_ = hard;
				_tmp8_ = fso_framework_serial_transport_new (_tmp4_, _tmp5_, _tmp6_, _tmp7_);
				result = (FsoFrameworkTransport*) _tmp8_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("pty")))) {
		switch (0) {
			default:
			{
				FsoFrameworkPtyTransport* _tmp9_;
				_tmp9_ = fso_framework_pty_transport_new ();
				result = (FsoFrameworkTransport*) _tmp9_;
				return result;
			}
		}
	} else if (((_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("unix")))) || (_tmp3_ == ((0 != _tmp2_label3) ? _tmp2_label3 : (_tmp2_label3 = g_quark_from_static_string ("udp"))))) || (_tmp3_ == ((0 != _tmp2_label4) ? _tmp2_label4 : (_tmp2_label4 = g_quark_from_static_string ("tcp"))))) {
		switch (0) {
			default:
			{
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				guint _tmp12_;
				FsoFrameworkSocketTransport* _tmp13_;
				_tmp10_ = type;
				_tmp11_ = name;
				_tmp12_ = speed;
				_tmp13_ = fso_framework_socket_transport_new (_tmp10_, _tmp11_, _tmp12_);
				result = (FsoFrameworkTransport*) _tmp13_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label5) ? _tmp2_label5 : (_tmp2_label5 = g_quark_from_static_string ("ngsm-basic")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp14_;
				guint _tmp15_;
				FsoFrameworkNgsmBasicMuxTransport* _tmp16_;
				_tmp14_ = name;
				_tmp15_ = speed;
				_tmp16_ = fso_framework_ngsm_basic_mux_transport_new (_tmp14_, _tmp15_, (guint) 64);
				result = (FsoFrameworkTransport*) _tmp16_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label6) ? _tmp2_label6 : (_tmp2_label6 = g_quark_from_static_string ("ngsm-advanced")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp17_;
				guint _tmp18_;
				FsoFrameworkNgsmAdvancedMuxTransport* _tmp19_;
				_tmp17_ = name;
				_tmp18_ = speed;
				_tmp19_ = fso_framework_ngsm_advanced_mux_transport_new (_tmp17_, _tmp18_, (guint) 64);
				result = (FsoFrameworkTransport*) _tmp19_;
				return result;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label7) ? _tmp2_label7 : (_tmp2_label7 = g_quark_from_static_string ("combined")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp20_;
				FsoFrameworkCombinedTransport* _tmp21_;
				_tmp20_ = name;
				_tmp21_ = fso_framework_combined_transport_new (_tmp20_);
				result = (FsoFrameworkTransport*) _tmp21_;
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				result = NULL;
				return result;
			}
		}
	}
}


/**
     * @returns true, if the @a transport is open; else false.
     */
static gboolean fso_framework_transport_real_isOpen (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_isOpen'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean fso_framework_transport_isOpen (FsoFrameworkTransport* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->isOpen (self);
}


void fso_framework_transport_openAsync (FsoFrameworkTransport* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->openAsync (self, _callback_, _user_data_);
}


gboolean fso_framework_transport_openAsync_finish (FsoFrameworkTransport* self, GAsyncResult* _res_) {
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->openAsync_finish (self, _res_);
}


/**
     * Close the transport. Closing an already closed transport is allowed.
     **/
static gboolean fso_framework_transport_real_open (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_open'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean fso_framework_transport_open (FsoFrameworkTransport* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->open (self);
}


/**
     * Close the transport. Closing an already closed transport is allowed.
     **/
static void fso_framework_transport_real_close (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_close'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_close (FsoFrameworkTransport* self) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->close (self);
}


/**
     * Return the transport identification.
     **/
static gchar* fso_framework_transport_real_getName (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_getName'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


gchar* fso_framework_transport_getName (FsoFrameworkTransport* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->getName (self);
}


/**
     * Set delegates for being called when there is something to read or there has been an exception.
     **/
static void fso_framework_transport_real_setDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc readfunc, void* readfunc_target, FsoFrameworkTransportFunc hupfunc, void* hupfunc_target) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_setDelegates'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_setDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc readfunc, void* readfunc_target, FsoFrameworkTransportFunc hupfunc, void* hupfunc_target) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->setDelegates (self, readfunc, readfunc_target, hupfunc, hupfunc_target);
}


/**
     * Get delegates
     **/
static void fso_framework_transport_real_getDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc* readfun, void** readfun_target, GDestroyNotify* readfun_target_destroy_notify, FsoFrameworkTransportFunc* hupfun, void** hupfun_target, GDestroyNotify* hupfun_target_destroy_notify) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_getDelegates'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_getDelegates (FsoFrameworkTransport* self, FsoFrameworkTransportFunc* readfun, void** readfun_target, GDestroyNotify* readfun_target_destroy_notify, FsoFrameworkTransportFunc* hupfun, void** hupfun_target, GDestroyNotify* hupfun_target_destroy_notify) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->getDelegates (self, readfun, readfun_target, readfun_target_destroy_notify, hupfun, hupfun_target, hupfun_target_destroy_notify);
}


/**
     * Set priorities for reading and writing
     **/
static void fso_framework_transport_real_setPriorities (FsoFrameworkTransport* self, gint rp, gint wp) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_setPriorities'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_setPriorities (FsoFrameworkTransport* self, gint rp, gint wp) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->setPriorities (self, rp, wp);
}


/**
     * Set buffered or unbuffered mode
     **/
static void fso_framework_transport_real_setBuffered (FsoFrameworkTransport* self, gboolean on) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_setBuffered'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_setBuffered (FsoFrameworkTransport* self, gboolean on) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->setBuffered (self, on);
}


/**
     * Write data to the transport and wait for a response.
     * Read the response into a buffer provided and owned by the caller.
     **/
static gint fso_framework_transport_real_writeAndRead (FsoFrameworkTransport* self, void* wdata, gint wlength, void* rdata, gint rlength, gint maxWait) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_writeAndRead'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


gint fso_framework_transport_writeAndRead (FsoFrameworkTransport* self, void* wdata, gint wlength, void* rdata, gint rlength, gint maxWait) {
	g_return_val_if_fail (self != NULL, 0);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->writeAndRead (self, wdata, wlength, rdata, rlength, maxWait);
}


/**
     * Read data from the transport into buffer provided and owned by caller.
     **/
static gint fso_framework_transport_real_read (FsoFrameworkTransport* self, void* data, gint length) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_read'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


gint fso_framework_transport_read (FsoFrameworkTransport* self, void* data, gint length) {
	g_return_val_if_fail (self != NULL, 0);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->read (self, data, length);
}


/**
     * Write data to the transport.
     **/
static gint fso_framework_transport_real_write (FsoFrameworkTransport* self, void* data, gint length) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_write'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


gint fso_framework_transport_write (FsoFrameworkTransport* self, void* data, gint length) {
	g_return_val_if_fail (self != NULL, 0);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->write (self, data, length);
}


/**
     * Pause reading and writing from/to the transport.
     * @returns the file descriptor that can now be used from another process.
     **/
static gint fso_framework_transport_real_freeze (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_freeze'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


gint fso_framework_transport_freeze (FsoFrameworkTransport* self) {
	g_return_val_if_fail (self != NULL, 0);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->freeze (self);
}


/**
     * Resume reading and writing from/to the transport.
     * @note This invalidates the file descriptor retuned by freeze().
     **/
static void fso_framework_transport_real_thaw (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_thaw'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_thaw (FsoFrameworkTransport* self) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->thaw (self);
}


/**
     * Drain the transport (wait until everything has been written to the underlying device)
     **/
static void fso_framework_transport_real_drain (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_drain'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_drain (FsoFrameworkTransport* self) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->drain (self);
}


/**
     * Flush the transport (discard everything in the buffers not sent)
     **/
static void fso_framework_transport_real_flush (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_flush'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_flush (FsoFrameworkTransport* self) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->flush (self);
}


/**
     * Suspend the transport. This is to handle hardware suspend of the underlaying
     * hardware and not the transport logic itself.
     **/
static gboolean fso_framework_transport_real_suspend (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_suspend'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean fso_framework_transport_suspend (FsoFrameworkTransport* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->suspend (self);
}


/**
     * Resumse the transport after it was suspended
     **/
static void fso_framework_transport_real_resume (FsoFrameworkTransport* self) {
	g_critical ("Type `%s' does not implement abstract method `fso_framework_transport_resume'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void fso_framework_transport_resume (FsoFrameworkTransport* self) {
	g_return_if_fail (self != NULL);
	FSO_FRAMEWORK_TRANSPORT_GET_CLASS (self)->resume (self);
}


FsoFrameworkTransport* fso_framework_transport_construct (GType object_type) {
	FsoFrameworkTransport * self = NULL;
	self = (FsoFrameworkTransport*) g_object_new (object_type, NULL);
	return self;
}


static void fso_framework_transport_class_init (FsoFrameworkTransportClass * klass) {
	fso_framework_transport_parent_class = g_type_class_peek_parent (klass);
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->isOpen = fso_framework_transport_real_isOpen;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->open = fso_framework_transport_real_open;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->close = fso_framework_transport_real_close;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->getName = fso_framework_transport_real_getName;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->setDelegates = fso_framework_transport_real_setDelegates;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->getDelegates = fso_framework_transport_real_getDelegates;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->setPriorities = fso_framework_transport_real_setPriorities;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->setBuffered = fso_framework_transport_real_setBuffered;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->writeAndRead = fso_framework_transport_real_writeAndRead;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->read = fso_framework_transport_real_read;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->write = fso_framework_transport_real_write;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->freeze = fso_framework_transport_real_freeze;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->thaw = fso_framework_transport_real_thaw;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->drain = fso_framework_transport_real_drain;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->flush = fso_framework_transport_real_flush;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->suspend = fso_framework_transport_real_suspend;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->resume = fso_framework_transport_real_resume;
	G_OBJECT_CLASS (klass)->finalize = fso_framework_transport_finalize;
}


static void fso_framework_transport_instance_init (FsoFrameworkTransport * self) {
}


static void fso_framework_transport_finalize (GObject* obj) {
	FsoFrameworkTransport * self;
	self = FSO_FRAMEWORK_TRANSPORT (obj);
	_g_object_unref0 (self->logger);
	G_OBJECT_CLASS (fso_framework_transport_parent_class)->finalize (obj);
}


GType fso_framework_transport_get_type (void) {
	static volatile gsize fso_framework_transport_type_id__volatile = 0;
	if (g_once_init_enter (&fso_framework_transport_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoFrameworkTransportClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_framework_transport_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoFrameworkTransport), 0, (GInstanceInitFunc) fso_framework_transport_instance_init, NULL };
		GType fso_framework_transport_type_id;
		fso_framework_transport_type_id = g_type_register_static (G_TYPE_OBJECT, "FsoFrameworkTransport", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&fso_framework_transport_type_id__volatile, fso_framework_transport_type_id);
	}
	return fso_framework_transport_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



