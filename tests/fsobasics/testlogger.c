/* testlogger.c generated by valac 0.16.0, the Vala compiler
 * generated from testlogger.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_REPR_DELEGATE_TESTER (repr_delegate_tester_get_type ())
#define REPR_DELEGATE_TESTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_REPR_DELEGATE_TESTER, ReprDelegateTester))
#define REPR_DELEGATE_TESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_REPR_DELEGATE_TESTER, ReprDelegateTesterClass))
#define IS_REPR_DELEGATE_TESTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_REPR_DELEGATE_TESTER))
#define IS_REPR_DELEGATE_TESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_REPR_DELEGATE_TESTER))
#define REPR_DELEGATE_TESTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_REPR_DELEGATE_TESTER, ReprDelegateTesterClass))

typedef struct _ReprDelegateTester ReprDelegateTester;
typedef struct _ReprDelegateTesterClass ReprDelegateTesterClass;
typedef struct _ReprDelegateTesterPrivate ReprDelegateTesterPrivate;
typedef struct _ParamSpecReprDelegateTester ParamSpecReprDelegateTester;
#define _repr_delegate_tester_unref0(var) ((var == NULL) ? NULL : (var = (repr_delegate_tester_unref (var), NULL)))

struct _ReprDelegateTester {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ReprDelegateTesterPrivate * priv;
	gboolean called;
};

struct _ReprDelegateTesterClass {
	GTypeClass parent_class;
	void (*finalize) (ReprDelegateTester *self);
};

struct _ParamSpecReprDelegateTester {
	GParamSpec parent_instance;
};


static gpointer repr_delegate_tester_parent_class = NULL;

#define TEST_FILE_NAME "/tmp/logfile.txt"
#define TEST_LOG_DOMAIN "my.logging.domain"
#define TEST_LOG_KEYFILE_NAME ".testlogger.ini"
#define TEST_LOG_KEYFILE ".testlogger.ini"
void test_logger_conversions (void);
void test_null_logger_new (void);
void test_file_logger_new (void);
gpointer repr_delegate_tester_ref (gpointer instance);
void repr_delegate_tester_unref (gpointer instance);
GParamSpec* param_spec_repr_delegate_tester (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_repr_delegate_tester (GValue* value, gpointer v_object);
void value_take_repr_delegate_tester (GValue* value, gpointer v_object);
gpointer value_get_repr_delegate_tester (const GValue* value);
GType repr_delegate_tester_get_type (void) G_GNUC_CONST;
enum  {
	REPR_DELEGATE_TESTER_DUMMY_PROPERTY
};
gchar* repr_delegate_tester_repr (ReprDelegateTester* self);
ReprDelegateTester* repr_delegate_tester_new (void);
ReprDelegateTester* repr_delegate_tester_construct (GType object_type);
static void repr_delegate_tester_finalize (ReprDelegateTester* obj);
void test_logger_reprdelegate (void);
static gchar* _repr_delegate_tester_repr_repr_delegate (gpointer self);
void test_syslog_logger_new (void);
void test_kmsg_logger_new (void);
void test_logger_create_from_keyfilename (void);
void test_logger_create_from_keyfile (void);
void _vala_main (gchar** args, int args_length1);
static void _test_logger_conversions_gcallback (void);
static void _test_logger_reprdelegate_gcallback (void);
static void _test_null_logger_new_gcallback (void);
static void _test_file_logger_new_gcallback (void);
static void _test_syslog_logger_new_gcallback (void);
static void _test_kmsg_logger_new_gcallback (void);


void test_logger_conversions (void) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	GLogLevelFlags _tmp8_ = 0;
	GLogLevelFlags _tmp9_ = 0;
	GLogLevelFlags _tmp10_ = 0;
	GLogLevelFlags _tmp11_ = 0;
	GLogLevelFlags _tmp12_ = 0;
	GLogLevelFlags _tmp13_ = 0;
	GLogLevelFlags _tmp14_ = 0;
	GLogLevelFlags _tmp15_ = 0;
	_tmp0_ = fso_framework_abstract_logger_levelToString (G_LOG_LEVEL_DEBUG);
	_tmp1_ = _tmp0_;
	g_assert (g_strcmp0 (_tmp1_, "DEBUG") == 0);
	_g_free0 (_tmp1_);
	_tmp2_ = fso_framework_abstract_logger_levelToString (G_LOG_LEVEL_INFO);
	_tmp3_ = _tmp2_;
	g_assert (g_strcmp0 (_tmp3_, "INFO") == 0);
	_g_free0 (_tmp3_);
	_tmp4_ = fso_framework_abstract_logger_levelToString (G_LOG_LEVEL_WARNING);
	_tmp5_ = _tmp4_;
	g_assert (g_strcmp0 (_tmp5_, "WARNING") == 0);
	_g_free0 (_tmp5_);
	_tmp6_ = fso_framework_abstract_logger_levelToString (G_LOG_LEVEL_ERROR);
	_tmp7_ = _tmp6_;
	g_assert (g_strcmp0 (_tmp7_, "ERROR") == 0);
	_g_free0 (_tmp7_);
	_tmp8_ = fso_framework_abstract_logger_stringToLevel ("debug");
	g_assert (_tmp8_ == G_LOG_LEVEL_DEBUG);
	_tmp9_ = fso_framework_abstract_logger_stringToLevel ("info");
	g_assert (_tmp9_ == G_LOG_LEVEL_INFO);
	_tmp10_ = fso_framework_abstract_logger_stringToLevel ("warning");
	g_assert (_tmp10_ == G_LOG_LEVEL_WARNING);
	_tmp11_ = fso_framework_abstract_logger_stringToLevel ("error");
	g_assert (_tmp11_ == G_LOG_LEVEL_ERROR);
	_tmp12_ = fso_framework_abstract_logger_stringToLevel ("DEBUG");
	g_assert (_tmp12_ == G_LOG_LEVEL_DEBUG);
	_tmp13_ = fso_framework_abstract_logger_stringToLevel ("INFO");
	g_assert (_tmp13_ == G_LOG_LEVEL_INFO);
	_tmp14_ = fso_framework_abstract_logger_stringToLevel ("WARNING");
	g_assert (_tmp14_ == G_LOG_LEVEL_WARNING);
	_tmp15_ = fso_framework_abstract_logger_stringToLevel ("ERROR");
	g_assert (_tmp15_ == G_LOG_LEVEL_ERROR);
}


void test_null_logger_new (void) {
	FsoFrameworkNullLogger* _tmp0_;
	FsoFrameworkNullLogger* logger;
	_tmp0_ = fso_framework_null_logger_new (TEST_LOG_DOMAIN);
	logger = _tmp0_;
	fso_framework_logger_setLevel ((FsoFrameworkLogger*) logger, G_LOG_LEVEL_DEBUG);
	fso_framework_logger_debug ((FsoFrameworkLogger*) logger, "foo");
	fso_framework_logger_info ((FsoFrameworkLogger*) logger, "bar");
	fso_framework_logger_warning ((FsoFrameworkLogger*) logger, "ham");
	fso_framework_logger_error ((FsoFrameworkLogger*) logger, "eggs");
	_g_object_unref0 (logger);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


void test_file_logger_new (void) {
	FsoFrameworkFileLogger* _tmp0_;
	FsoFrameworkFileLogger* logger;
	FsoFrameworkFileLogger* _tmp1_;
	FsoFrameworkFileLogger* _tmp2_;
	FsoFrameworkFileLogger* _tmp3_;
	FsoFrameworkFileLogger* _tmp4_;
	FsoFrameworkFileLogger* _tmp5_;
	FsoFrameworkFileLogger* _tmp6_;
	GFile* _tmp7_ = NULL;
	GFile* file;
	GFile* _tmp8_;
	gboolean _tmp9_ = FALSE;
	GFile* _tmp10_;
	GFileInputStream* _tmp11_ = NULL;
	GFileInputStream* _tmp12_;
	GFileInputStream* _tmp13_;
	GDataInputStream* _tmp14_;
	GDataInputStream* _tmp15_;
	GDataInputStream* stream;
	GDataInputStream* _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* line1;
	gboolean _tmp18_ = FALSE;
	const gchar* _tmp19_;
	gboolean _tmp20_ = FALSE;
	gboolean _tmp23_;
	GDataInputStream* _tmp24_;
	gchar* _tmp25_ = NULL;
	gchar* line2;
	gboolean _tmp26_ = FALSE;
	const gchar* _tmp27_;
	gboolean _tmp28_ = FALSE;
	gboolean _tmp31_;
	GDataInputStream* _tmp32_;
	gchar* _tmp33_ = NULL;
	gchar* line3;
	gboolean _tmp34_ = FALSE;
	const gchar* _tmp35_;
	gboolean _tmp36_ = FALSE;
	gboolean _tmp39_;
	GDataInputStream* _tmp40_;
	gchar* _tmp41_ = NULL;
	gchar* line4;
	gboolean _tmp42_ = FALSE;
	const gchar* _tmp43_;
	gboolean _tmp44_ = FALSE;
	gboolean _tmp47_;
	GError * _inner_error_ = NULL;
	g_remove (TEST_FILE_NAME);
	_tmp0_ = fso_framework_file_logger_new (TEST_LOG_DOMAIN);
	logger = _tmp0_;
	_tmp1_ = logger;
	fso_framework_file_logger_setFile (_tmp1_, TEST_FILE_NAME, FALSE);
	_tmp2_ = logger;
	fso_framework_logger_setLevel ((FsoFrameworkLogger*) _tmp2_, G_LOG_LEVEL_DEBUG);
	_tmp3_ = logger;
	fso_framework_logger_debug ((FsoFrameworkLogger*) _tmp3_, "foo");
	_tmp4_ = logger;
	fso_framework_logger_info ((FsoFrameworkLogger*) _tmp4_, "bar");
	_tmp5_ = logger;
	fso_framework_logger_warning ((FsoFrameworkLogger*) _tmp5_, "ham");
	_tmp6_ = logger;
	fso_framework_logger_error ((FsoFrameworkLogger*) _tmp6_, "eggs");
	_tmp7_ = g_file_new_for_path (TEST_FILE_NAME);
	file = _tmp7_;
	_tmp8_ = file;
	_tmp9_ = g_file_query_exists (_tmp8_, NULL);
	g_assert (_tmp9_);
	_tmp10_ = file;
	_tmp11_ = g_file_read (_tmp10_, NULL, &_inner_error_);
	_tmp12_ = _tmp11_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file);
		_g_object_unref0 (logger);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp13_ = _tmp12_;
	_tmp14_ = g_data_input_stream_new ((GInputStream*) _tmp13_);
	_tmp15_ = _tmp14_;
	_g_object_unref0 (_tmp13_);
	stream = _tmp15_;
	_tmp16_ = stream;
	_tmp17_ = g_data_input_stream_read_line (_tmp16_, NULL, NULL, &_inner_error_);
	line1 = _tmp17_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (stream);
		_g_object_unref0 (file);
		_g_object_unref0 (logger);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp19_ = line1;
	_tmp20_ = string_contains (_tmp19_, "DEBUG");
	if (_tmp20_) {
		const gchar* _tmp21_;
		gboolean _tmp22_ = FALSE;
		_tmp21_ = line1;
		_tmp22_ = string_contains (_tmp21_, "foo");
		_tmp18_ = _tmp22_;
	} else {
		_tmp18_ = FALSE;
	}
	_tmp23_ = _tmp18_;
	g_assert (_tmp23_);
	_tmp24_ = stream;
	_tmp25_ = g_data_input_stream_read_line (_tmp24_, NULL, NULL, &_inner_error_);
	line2 = _tmp25_;
	if (_inner_error_ != NULL) {
		_g_free0 (line1);
		_g_object_unref0 (stream);
		_g_object_unref0 (file);
		_g_object_unref0 (logger);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp27_ = line2;
	_tmp28_ = string_contains (_tmp27_, "INFO");
	if (_tmp28_) {
		const gchar* _tmp29_;
		gboolean _tmp30_ = FALSE;
		_tmp29_ = line2;
		_tmp30_ = string_contains (_tmp29_, "bar");
		_tmp26_ = _tmp30_;
	} else {
		_tmp26_ = FALSE;
	}
	_tmp31_ = _tmp26_;
	g_assert (_tmp31_);
	_tmp32_ = stream;
	_tmp33_ = g_data_input_stream_read_line (_tmp32_, NULL, NULL, &_inner_error_);
	line3 = _tmp33_;
	if (_inner_error_ != NULL) {
		_g_free0 (line2);
		_g_free0 (line1);
		_g_object_unref0 (stream);
		_g_object_unref0 (file);
		_g_object_unref0 (logger);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp35_ = line3;
	_tmp36_ = string_contains (_tmp35_, "WARN");
	if (_tmp36_) {
		const gchar* _tmp37_;
		gboolean _tmp38_ = FALSE;
		_tmp37_ = line3;
		_tmp38_ = string_contains (_tmp37_, "ham");
		_tmp34_ = _tmp38_;
	} else {
		_tmp34_ = FALSE;
	}
	_tmp39_ = _tmp34_;
	g_assert (_tmp39_);
	_tmp40_ = stream;
	_tmp41_ = g_data_input_stream_read_line (_tmp40_, NULL, NULL, &_inner_error_);
	line4 = _tmp41_;
	if (_inner_error_ != NULL) {
		_g_free0 (line3);
		_g_free0 (line2);
		_g_free0 (line1);
		_g_object_unref0 (stream);
		_g_object_unref0 (file);
		_g_object_unref0 (logger);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp43_ = line4;
	_tmp44_ = string_contains (_tmp43_, "ERROR");
	if (_tmp44_) {
		const gchar* _tmp45_;
		gboolean _tmp46_ = FALSE;
		_tmp45_ = line4;
		_tmp46_ = string_contains (_tmp45_, "eggs");
		_tmp42_ = _tmp46_;
	} else {
		_tmp42_ = FALSE;
	}
	_tmp47_ = _tmp42_;
	g_assert (_tmp47_);
	_g_free0 (line4);
	_g_free0 (line3);
	_g_free0 (line2);
	_g_free0 (line1);
	_g_object_unref0 (stream);
	_g_object_unref0 (file);
	_g_object_unref0 (logger);
}


gchar* repr_delegate_tester_repr (ReprDelegateTester* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	self->called = TRUE;
	_tmp0_ = g_strdup ("<representation>");
	result = _tmp0_;
	return result;
}


ReprDelegateTester* repr_delegate_tester_construct (GType object_type) {
	ReprDelegateTester* self = NULL;
	self = (ReprDelegateTester*) g_type_create_instance (object_type);
	return self;
}


ReprDelegateTester* repr_delegate_tester_new (void) {
	return repr_delegate_tester_construct (TYPE_REPR_DELEGATE_TESTER);
}


static void value_repr_delegate_tester_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_repr_delegate_tester_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		repr_delegate_tester_unref (value->data[0].v_pointer);
	}
}


static void value_repr_delegate_tester_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = repr_delegate_tester_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_repr_delegate_tester_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_repr_delegate_tester_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ReprDelegateTester* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = repr_delegate_tester_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_repr_delegate_tester_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ReprDelegateTester** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = repr_delegate_tester_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_repr_delegate_tester (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecReprDelegateTester* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_REPR_DELEGATE_TESTER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_repr_delegate_tester (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_REPR_DELEGATE_TESTER), NULL);
	return value->data[0].v_pointer;
}


void value_set_repr_delegate_tester (GValue* value, gpointer v_object) {
	ReprDelegateTester* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_REPR_DELEGATE_TESTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_REPR_DELEGATE_TESTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		repr_delegate_tester_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		repr_delegate_tester_unref (old);
	}
}


void value_take_repr_delegate_tester (GValue* value, gpointer v_object) {
	ReprDelegateTester* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_REPR_DELEGATE_TESTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_REPR_DELEGATE_TESTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		repr_delegate_tester_unref (old);
	}
}


static void repr_delegate_tester_class_init (ReprDelegateTesterClass * klass) {
	repr_delegate_tester_parent_class = g_type_class_peek_parent (klass);
	REPR_DELEGATE_TESTER_CLASS (klass)->finalize = repr_delegate_tester_finalize;
}


static void repr_delegate_tester_instance_init (ReprDelegateTester * self) {
	self->ref_count = 1;
}


static void repr_delegate_tester_finalize (ReprDelegateTester* obj) {
	ReprDelegateTester * self;
	self = REPR_DELEGATE_TESTER (obj);
}


GType repr_delegate_tester_get_type (void) {
	static volatile gsize repr_delegate_tester_type_id__volatile = 0;
	if (g_once_init_enter (&repr_delegate_tester_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_repr_delegate_tester_init, value_repr_delegate_tester_free_value, value_repr_delegate_tester_copy_value, value_repr_delegate_tester_peek_pointer, "p", value_repr_delegate_tester_collect_value, "p", value_repr_delegate_tester_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ReprDelegateTesterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) repr_delegate_tester_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ReprDelegateTester), 0, (GInstanceInitFunc) repr_delegate_tester_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType repr_delegate_tester_type_id;
		repr_delegate_tester_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ReprDelegateTester", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&repr_delegate_tester_type_id__volatile, repr_delegate_tester_type_id);
	}
	return repr_delegate_tester_type_id__volatile;
}


gpointer repr_delegate_tester_ref (gpointer instance) {
	ReprDelegateTester* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void repr_delegate_tester_unref (gpointer instance) {
	ReprDelegateTester* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		REPR_DELEGATE_TESTER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gchar* _repr_delegate_tester_repr_repr_delegate (gpointer self) {
	gchar* result;
	result = repr_delegate_tester_repr (self);
	return result;
}


void test_logger_reprdelegate (void) {
	FsoFrameworkFileLogger* _tmp0_;
	FsoFrameworkFileLogger* logger;
	ReprDelegateTester* _tmp1_;
	ReprDelegateTester* r;
	gboolean _tmp2_;
	_tmp0_ = fso_framework_file_logger_new (TEST_LOG_DOMAIN);
	logger = _tmp0_;
	fso_framework_file_logger_setFile (logger, "/dev/null", FALSE);
	_tmp1_ = repr_delegate_tester_new ();
	r = _tmp1_;
	r->called = FALSE;
	fso_framework_logger_setReprDelegate ((FsoFrameworkLogger*) logger, _repr_delegate_tester_repr_repr_delegate, r);
	fso_framework_logger_warning ((FsoFrameworkLogger*) logger, "foo");
	_tmp2_ = r->called;
	g_assert (_tmp2_);
	_repr_delegate_tester_unref0 (r);
	_g_object_unref0 (logger);
}


void test_syslog_logger_new (void) {
	FsoFrameworkSyslogLogger* _tmp0_;
	FsoFrameworkSyslogLogger* logger;
	_tmp0_ = fso_framework_syslog_logger_new (TEST_LOG_DOMAIN);
	logger = _tmp0_;
	fso_framework_logger_setLevel ((FsoFrameworkLogger*) logger, G_LOG_LEVEL_DEBUG);
	fso_framework_logger_debug ((FsoFrameworkLogger*) logger, "foo");
	_g_object_unref0 (logger);
}


void test_kmsg_logger_new (void) {
	FsoFrameworkKmsgLogger* _tmp0_;
	FsoFrameworkKmsgLogger* logger;
	_tmp0_ = fso_framework_kmsg_logger_new (TEST_LOG_DOMAIN);
	logger = _tmp0_;
	fso_framework_logger_setLevel ((FsoFrameworkLogger*) logger, G_LOG_LEVEL_DEBUG);
	fso_framework_logger_debug ((FsoFrameworkLogger*) logger, "foo");
	_g_object_unref0 (logger);
}


void test_logger_create_from_keyfilename (void) {
	FsoFrameworkLogger* _tmp0_ = NULL;
	FsoFrameworkLogger* logger;
	FsoFrameworkLogger* _tmp1_;
	GType _tmp2_ = 0UL;
	FsoFrameworkLogger* _tmp3_ = NULL;
	FsoFrameworkLogger* _tmp4_;
	GType _tmp5_ = 0UL;
	FsoFrameworkLogger* _tmp6_;
	GLogLevelFlags _tmp7_ = 0;
	FsoFrameworkLogger* _tmp8_ = NULL;
	FsoFrameworkLogger* _tmp9_;
	GType _tmp10_ = 0UL;
	FsoFrameworkLogger* _tmp11_;
	GLogLevelFlags _tmp12_ = 0;
	FsoFrameworkLogger* _tmp13_ = NULL;
	FsoFrameworkLogger* _tmp14_;
	GType _tmp15_ = 0UL;
	FsoFrameworkLogger* _tmp16_;
	GLogLevelFlags _tmp17_ = 0;
	FsoFrameworkLogger* _tmp18_;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_;
	FsoFrameworkLogger* _tmp21_ = NULL;
	FsoFrameworkLogger* _tmp22_;
	GType _tmp23_ = 0UL;
	FsoFrameworkLogger* _tmp24_;
	GLogLevelFlags _tmp25_ = 0;
	_tmp0_ = fso_framework_logger_createFromKeyFileName (TEST_LOG_KEYFILE_NAME, "nologger", TEST_LOG_DOMAIN);
	logger = _tmp0_;
	_tmp1_ = logger;
	_tmp2_ = G_TYPE_FROM_INSTANCE (_tmp1_);
	g_assert (_tmp2_ == FSO_FRAMEWORK_TYPE_STD_ERR_LOGGER);
	_tmp3_ = fso_framework_logger_createFromKeyFileName (TEST_LOG_KEYFILE_NAME, "stderr", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp3_;
	_tmp4_ = logger;
	_tmp5_ = G_TYPE_FROM_INSTANCE (_tmp4_);
	g_assert (_tmp5_ == FSO_FRAMEWORK_TYPE_STD_ERR_LOGGER);
	_tmp6_ = logger;
	_tmp7_ = fso_framework_logger_getLevel (_tmp6_);
	g_assert (_tmp7_ == G_LOG_LEVEL_DEBUG);
	_tmp8_ = fso_framework_logger_createFromKeyFileName (TEST_LOG_KEYFILE_NAME, "syslog", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp8_;
	_tmp9_ = logger;
	_tmp10_ = G_TYPE_FROM_INSTANCE (_tmp9_);
	g_assert (_tmp10_ == FSO_FRAMEWORK_TYPE_SYSLOG_LOGGER);
	_tmp11_ = logger;
	_tmp12_ = fso_framework_logger_getLevel (_tmp11_);
	g_assert (_tmp12_ == G_LOG_LEVEL_INFO);
	_tmp13_ = fso_framework_logger_createFromKeyFileName (TEST_LOG_KEYFILE_NAME, "file", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp13_;
	_tmp14_ = logger;
	_tmp15_ = G_TYPE_FROM_INSTANCE (_tmp14_);
	g_assert (_tmp15_ == FSO_FRAMEWORK_TYPE_FILE_LOGGER);
	_tmp16_ = logger;
	_tmp17_ = fso_framework_logger_getLevel (_tmp16_);
	g_assert (_tmp17_ == G_LOG_LEVEL_WARNING);
	_tmp18_ = logger;
	_tmp19_ = fso_framework_logger_getDestination (_tmp18_);
	_tmp20_ = _tmp19_;
	g_assert (g_strcmp0 (_tmp20_, "log.txt") == 0);
	_g_free0 (_tmp20_);
	_tmp21_ = fso_framework_logger_createFromKeyFileName (TEST_LOG_KEYFILE_NAME, "kmsg", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp21_;
	_tmp22_ = logger;
	_tmp23_ = G_TYPE_FROM_INSTANCE (_tmp22_);
	g_assert (_tmp23_ == FSO_FRAMEWORK_TYPE_KMSG_LOGGER);
	_tmp24_ = logger;
	_tmp25_ = fso_framework_logger_getLevel (_tmp24_);
	g_assert (_tmp25_ == G_LOG_LEVEL_WARNING);
	_g_object_unref0 (logger);
}


void test_logger_create_from_keyfile (void) {
	FsoFrameworkSmartKeyFile* _tmp0_;
	FsoFrameworkSmartKeyFile* smk;
	FsoFrameworkLogger* _tmp1_ = NULL;
	FsoFrameworkLogger* logger;
	FsoFrameworkLogger* _tmp2_;
	GType _tmp3_ = 0UL;
	FsoFrameworkLogger* _tmp4_ = NULL;
	FsoFrameworkLogger* _tmp5_;
	GType _tmp6_ = 0UL;
	FsoFrameworkLogger* _tmp7_;
	GLogLevelFlags _tmp8_ = 0;
	FsoFrameworkLogger* _tmp9_ = NULL;
	FsoFrameworkLogger* _tmp10_;
	GType _tmp11_ = 0UL;
	FsoFrameworkLogger* _tmp12_;
	GLogLevelFlags _tmp13_ = 0;
	FsoFrameworkLogger* _tmp14_ = NULL;
	FsoFrameworkLogger* _tmp15_;
	GType _tmp16_ = 0UL;
	FsoFrameworkLogger* _tmp17_;
	GLogLevelFlags _tmp18_ = 0;
	FsoFrameworkLogger* _tmp19_;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	FsoFrameworkLogger* _tmp22_ = NULL;
	FsoFrameworkLogger* _tmp23_;
	GType _tmp24_ = 0UL;
	FsoFrameworkLogger* _tmp25_;
	GLogLevelFlags _tmp26_ = 0;
	_tmp0_ = fso_framework_smart_key_file_new ();
	smk = _tmp0_;
	fso_framework_smart_key_file_loadFromFile (smk, TEST_LOG_KEYFILE);
	_tmp1_ = fso_framework_logger_createFromKeyFile (smk, "nologger", TEST_LOG_DOMAIN);
	logger = _tmp1_;
	_tmp2_ = logger;
	_tmp3_ = G_TYPE_FROM_INSTANCE (_tmp2_);
	g_assert (_tmp3_ == FSO_FRAMEWORK_TYPE_STD_ERR_LOGGER);
	_tmp4_ = fso_framework_logger_createFromKeyFile (smk, "stderr", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp4_;
	_tmp5_ = logger;
	_tmp6_ = G_TYPE_FROM_INSTANCE (_tmp5_);
	g_assert (_tmp6_ == FSO_FRAMEWORK_TYPE_STD_ERR_LOGGER);
	_tmp7_ = logger;
	_tmp8_ = fso_framework_logger_getLevel (_tmp7_);
	g_assert (_tmp8_ == G_LOG_LEVEL_DEBUG);
	_tmp9_ = fso_framework_logger_createFromKeyFile (smk, "syslog", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp9_;
	_tmp10_ = logger;
	_tmp11_ = G_TYPE_FROM_INSTANCE (_tmp10_);
	g_assert (_tmp11_ == FSO_FRAMEWORK_TYPE_SYSLOG_LOGGER);
	_tmp12_ = logger;
	_tmp13_ = fso_framework_logger_getLevel (_tmp12_);
	g_assert (_tmp13_ == G_LOG_LEVEL_INFO);
	_tmp14_ = fso_framework_logger_createFromKeyFile (smk, "file", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp14_;
	_tmp15_ = logger;
	_tmp16_ = G_TYPE_FROM_INSTANCE (_tmp15_);
	g_assert (_tmp16_ == FSO_FRAMEWORK_TYPE_FILE_LOGGER);
	_tmp17_ = logger;
	_tmp18_ = fso_framework_logger_getLevel (_tmp17_);
	g_assert (_tmp18_ == G_LOG_LEVEL_WARNING);
	_tmp19_ = logger;
	_tmp20_ = fso_framework_logger_getDestination (_tmp19_);
	_tmp21_ = _tmp20_;
	g_assert (g_strcmp0 (_tmp21_, "log.txt") == 0);
	_g_free0 (_tmp21_);
	_tmp22_ = fso_framework_logger_createFromKeyFile (smk, "kmsg", TEST_LOG_DOMAIN);
	_g_object_unref0 (logger);
	logger = _tmp22_;
	_tmp23_ = logger;
	_tmp24_ = G_TYPE_FROM_INSTANCE (_tmp23_);
	g_assert (_tmp24_ == FSO_FRAMEWORK_TYPE_KMSG_LOGGER);
	_tmp25_ = logger;
	_tmp26_ = fso_framework_logger_getLevel (_tmp25_);
	g_assert (_tmp26_ == G_LOG_LEVEL_WARNING);
	_g_object_unref0 (logger);
	_g_object_unref0 (smk);
}


static void _test_logger_conversions_gcallback (void) {
	test_logger_conversions ();
}


static void _test_logger_reprdelegate_gcallback (void) {
	test_logger_reprdelegate ();
}


static void _test_null_logger_new_gcallback (void) {
	test_null_logger_new ();
}


static void _test_file_logger_new_gcallback (void) {
	test_file_logger_new ();
}


static void _test_syslog_logger_new_gcallback (void) {
	test_syslog_logger_new ();
}


static void _test_kmsg_logger_new_gcallback (void) {
	test_kmsg_logger_new ();
}


void _vala_main (gchar** args, int args_length1) {
	g_test_init (&args_length1, &args, NULL);
	g_test_add_func ("/Logger/Conversions", _test_logger_conversions_gcallback);
	g_test_add_func ("/Logger/ReprDelegate", _test_logger_reprdelegate_gcallback);
	g_test_add_func ("/NullLogger/New", _test_null_logger_new_gcallback);
	g_test_add_func ("/FileLogger/New", _test_file_logger_new_gcallback);
	g_test_add_func ("/SyslogLogger/New", _test_syslog_logger_new_gcallback);
	g_test_add_func ("/Kmsg/New", _test_kmsg_logger_new_gcallback);
	g_test_run ();
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}



