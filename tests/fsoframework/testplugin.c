/* testplugin.c generated by valac 0.16.0, the Vala compiler
 * generated from testplugin.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <fsoframework.h>
#include <stdlib.h>
#include <string.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))



void test_plugin_all (void);
void _vala_main (gchar** args, int args_length1);
static void _test_plugin_all_gcallback (void);


/**
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */
void test_plugin_all (void) {
	FsoFrameworkPlugin* p = NULL;
	FsoFrameworkBaseSubsystem* _tmp0_;
	FsoFrameworkSubsystem* s;
	FsoFrameworkBasePlugin* _tmp1_;
	FsoFrameworkBasePlugin* _tmp9_;
	FsoFrameworkPlugin* _tmp10_;
	FsoFrameworkPlugin* _tmp11_;
	FsoFrameworkPluginInfo _tmp12_ = {0};
	FsoFrameworkPluginInfo info;
	FsoFrameworkPluginInfo _tmp13_;
	const gchar* _tmp14_;
	FsoFrameworkPluginInfo _tmp15_;
	gboolean _tmp16_;
	GError * _inner_error_ = NULL;
	_tmp0_ = fso_framework_base_subsystem_new ("dummy");
	s = (FsoFrameworkSubsystem*) _tmp0_;
	_tmp1_ = fso_framework_base_plugin_new ("./this/path/not/existing", s);
	_g_object_unref0 (p);
	p = (FsoFrameworkPlugin*) _tmp1_;
	{
		FsoFrameworkPlugin* _tmp2_;
		_tmp2_ = p;
		fso_framework_plugin_loadAndInit (_tmp2_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == FSO_FRAMEWORK_PLUGIN_ERROR) {
				goto __catch0_fso_framework_plugin_error;
			}
			_g_object_unref0 (s);
			_g_object_unref0 (p);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		g_assert_not_reached ();
	}
	goto __finally0;
	__catch0_fso_framework_plugin_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert (g_error_matches (e, FSO_FRAMEWORK_PLUGIN_ERROR, FSO_FRAMEWORK_PLUGIN_ERROR_UNABLE_TO_LOAD));
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (s);
		_g_object_unref0 (p);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		FsoFrameworkBasePlugin* _tmp3_;
		FsoFrameworkBasePlugin* _tmp4_;
		_tmp3_ = fso_framework_base_plugin_new ("./.libs/pluginc", s);
		_tmp4_ = _tmp3_;
		fso_framework_plugin_loadAndInit ((FsoFrameworkPlugin*) _tmp4_, &_inner_error_);
		_g_object_unref0 (_tmp4_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == FSO_FRAMEWORK_PLUGIN_ERROR) {
				goto __catch1_fso_framework_plugin_error;
			}
			_g_object_unref0 (s);
			_g_object_unref0 (p);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		g_assert_not_reached ();
	}
	goto __finally1;
	__catch1_fso_framework_plugin_error:
	{
		GError* e = NULL;
		GError* _tmp5_;
		GError* _tmp8_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		if (!g_error_matches (_tmp5_, FSO_FRAMEWORK_PLUGIN_ERROR, FSO_FRAMEWORK_PLUGIN_ERROR_UNABLE_TO_INITIALIZE)) {
			GError* _tmp6_;
			const gchar* _tmp7_;
			_tmp6_ = e;
			_tmp7_ = _tmp6_->message;
			g_warning ("testplugin.vala:49: got wrong pluginerror: %s", _tmp7_);
		}
		_tmp8_ = e;
		g_assert (g_error_matches (_tmp8_, FSO_FRAMEWORK_PLUGIN_ERROR, FSO_FRAMEWORK_PLUGIN_ERROR_UNABLE_TO_INITIALIZE));
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (s);
		_g_object_unref0 (p);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp9_ = fso_framework_base_plugin_new ("./.libs/plugin", s);
	_g_object_unref0 (p);
	p = (FsoFrameworkPlugin*) _tmp9_;
	_tmp10_ = p;
	fso_framework_plugin_loadAndInit (_tmp10_, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (s);
		_g_object_unref0 (p);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp11_ = p;
	fso_framework_plugin_info (_tmp11_, &_tmp12_);
	info = _tmp12_;
	_tmp13_ = info;
	_tmp14_ = _tmp13_.name;
	g_assert (g_strcmp0 (_tmp14_, "test.plugin") == 0);
	_tmp15_ = info;
	_tmp16_ = _tmp15_.loaded;
	g_assert (_tmp16_);
	fso_framework_plugin_info_destroy (&info);
	_g_object_unref0 (s);
	_g_object_unref0 (p);
}


static void _test_plugin_all_gcallback (void) {
	test_plugin_all ();
}


void _vala_main (gchar** args, int args_length1) {
	g_test_init (&args_length1, &args, NULL);
	g_test_add_func ("/Plugin/all", _test_plugin_all_gcallback);
	g_test_run ();
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}



