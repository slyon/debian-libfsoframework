/* testtransport.c generated by valac 0.16.0, the Vala compiler
 * generated from testtransport.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <fsotransport.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _fso_framework_transport_spec_unref0(var) ((var == NULL) ? NULL : (var = (fso_framework_transport_spec_unref (var), NULL)))


extern gchar* buffer;
extern gint buffer_length1;
gchar* buffer = NULL;
gint buffer_length1 = 0;
static gint _buffer_size_ = 0;
extern gchar* readline;
gchar* readline = NULL;
extern gboolean gotHup;
gboolean gotHup = FALSE;
extern gboolean frozen;
gboolean frozen = FALSE;

#define TRANSPORT_TEST_STRING ((gchar*) "\r\n+DATA: FOO\r\n")
#define TRANSPORT_READ_STRING ((gchar*) "\r\n+CMS ERROR: YO KURT\r\n")
void transport_read_func (FsoFrameworkTransport* transport);
void transport_hup_func (FsoFrameworkTransport* transport);
void test_transport_base (void);
static void _transport_read_func_fso_framework_transport_func (FsoFrameworkTransport* transport, gpointer self);
static void _transport_hup_func_fso_framework_transport_func (FsoFrameworkTransport* transport, gpointer self);
void test_transport_null (void);
void test_transport_serial (void);
void test_transport_pty (void);
void test_transport_pty_write (void);
void test_transport_pty_read (void);
void test_transport_pty_hup (void);
void test_transport_pty_freeze_thaw (void);
void test_transport_spec_from_config (void);
void _vala_main (gchar** args, int args_length1);
static void _test_transport_base_gcallback (void);
static void _test_transport_null_gcallback (void);
static void _test_transport_serial_gcallback (void);
static void _test_transport_pty_gcallback (void);
static void _test_transport_pty_write_gcallback (void);
static void _test_transport_pty_read_gcallback (void);
static void _test_transport_pty_hup_gcallback (void);
static void _test_transport_pty_freeze_thaw_gcallback (void);
static void _test_transport_spec_from_config_gcallback (void);


void transport_read_func (FsoFrameworkTransport* transport) {
	gboolean _tmp0_;
	gchar* _tmp1_ = NULL;
	FsoFrameworkTransport* _tmp2_;
	gchar* _tmp3_;
	gint _tmp3__length1;
	gint _tmp4_ = 0;
	gint bytesread;
	gchar* _tmp5_;
	gint _tmp5__length1;
	gchar _tmp6_;
	gchar* _tmp7_;
	gint _tmp7__length1;
	gchar* _tmp8_;
	g_return_if_fail (transport != NULL);
	g_message ("testtransport.vala:33: read delegate called");
	_tmp0_ = frozen;
	g_assert (!_tmp0_);
	_tmp1_ = g_new0 (gchar, 512);
	buffer = (g_free (buffer), NULL);
	buffer = _tmp1_;
	buffer_length1 = 512;
	_buffer_size_ = buffer_length1;
	_tmp2_ = transport;
	_tmp3_ = buffer;
	_tmp3__length1 = buffer_length1;
	_tmp4_ = fso_framework_transport_read (_tmp2_, (void*) _tmp3_, 512);
	bytesread = _tmp4_;
	_tmp5_ = buffer;
	_tmp5__length1 = buffer_length1;
	_tmp5_[bytesread] = (gchar) 0;
	_tmp6_ = _tmp5_[bytesread];
	_tmp7_ = buffer;
	_tmp7__length1 = buffer_length1;
	_tmp8_ = g_strdup ((const gchar*) _tmp7_);
	_g_free0 (readline);
	readline = _tmp8_;
}


void transport_hup_func (FsoFrameworkTransport* transport) {
	FsoFrameworkTransport* _tmp0_;
	g_return_if_fail (transport != NULL);
	g_message ("testtransport.vala:43: hup delegate called");
	gotHup = TRUE;
	_tmp0_ = transport;
	fso_framework_transport_close (_tmp0_);
}


static void _transport_read_func_fso_framework_transport_func (FsoFrameworkTransport* transport, gpointer self) {
	transport_read_func (transport);
}


static void _transport_hup_func_fso_framework_transport_func (FsoFrameworkTransport* transport, gpointer self) {
	transport_hup_func (transport);
}


void test_transport_base (void) {
	FsoFrameworkBaseTransport* _tmp0_;
	FsoFrameworkBaseTransport* t;
	FsoFrameworkTransportFunc hupfunc = NULL;
	void* hupfunc_target = NULL;
	GDestroyNotify hupfunc_target_destroy_notify = NULL;
	FsoFrameworkTransportFunc readfunc = NULL;
	void* readfunc_target = NULL;
	GDestroyNotify readfunc_target_destroy_notify = NULL;
	_tmp0_ = fso_framework_base_transport_new ("testing", (guint) 0, TRUE, TRUE);
	t = _tmp0_;
	fso_framework_transport_setDelegates ((FsoFrameworkTransport*) t, _transport_read_func_fso_framework_transport_func, NULL, _transport_hup_func_fso_framework_transport_func, NULL);
	(readfunc_target_destroy_notify == NULL) ? NULL : (readfunc_target_destroy_notify (readfunc_target), NULL);
	readfunc = NULL;
	readfunc_target = NULL;
	readfunc_target_destroy_notify = NULL;
	(hupfunc_target_destroy_notify == NULL) ? NULL : (hupfunc_target_destroy_notify (hupfunc_target), NULL);
	hupfunc = NULL;
	hupfunc_target = NULL;
	hupfunc_target_destroy_notify = NULL;
	_g_object_unref0 (t);
}


void test_transport_null (void) {
	FsoFrameworkNullTransport* _tmp0_;
	FsoFrameworkNullTransport* t;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	_tmp0_ = fso_framework_null_transport_new ("null", (guint) 0, TRUE, TRUE);
	t = _tmp0_;
	_tmp1_ = fso_framework_transport_open ((FsoFrameworkTransport*) t);
	g_assert (_tmp1_);
	_tmp2_ = fso_framework_transport_isOpen ((FsoFrameworkTransport*) t);
	g_assert (_tmp2_);
	_tmp3_ = fso_framework_transport_write ((FsoFrameworkTransport*) t, (void*) 0xdeadbeefLL, 10);
	g_assert (_tmp3_ == 10);
	_tmp4_ = fso_framework_transport_read ((FsoFrameworkTransport*) t, (void*) 0xdeadbeefLL, 42);
	g_assert (_tmp4_ == 42);
	fso_framework_transport_freeze ((FsoFrameworkTransport*) t);
	fso_framework_transport_thaw ((FsoFrameworkTransport*) t);
	_g_object_unref0 (t);
}


void test_transport_serial (void) {
	FsoFrameworkSerialTransport* _tmp0_;
	FsoFrameworkSerialTransport* t;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	mkfifo ("./myfifo", ((((S_IRUSR | S_IWUSR) | S_IRGRP) | S_IWGRP) | S_IROTH) | S_IWOTH);
	_tmp0_ = fso_framework_serial_transport_new ("./myfifo", (guint) 115200, TRUE, TRUE);
	t = _tmp0_;
	fso_framework_transport_open ((FsoFrameworkTransport*) t);
	_tmp1_ = fso_framework_transport_getName ((FsoFrameworkTransport*) t);
	_tmp2_ = _tmp1_;
	g_assert (g_strcmp0 (_tmp2_, "./myfifo") == 0);
	_g_free0 (_tmp2_);
	fso_framework_transport_close ((FsoFrameworkTransport*) t);
	unlink ("./myfifo");
	_g_object_unref0 (t);
}


void test_transport_pty (void) {
	FsoFrameworkPtyTransport* _tmp0_;
	FsoFrameworkPtyTransport* t1;
	gchar* _tmp1_ = NULL;
	gchar* name1;
	gboolean _tmp2_ = FALSE;
	FsoFrameworkPtyTransport* _tmp3_;
	FsoFrameworkPtyTransport* t2;
	gchar* _tmp4_ = NULL;
	gchar* name2;
	gboolean _tmp5_ = FALSE;
	_tmp0_ = fso_framework_pty_transport_new ();
	t1 = _tmp0_;
	fso_framework_transport_open ((FsoFrameworkTransport*) t1);
	_tmp1_ = fso_framework_transport_getName ((FsoFrameworkTransport*) t1);
	name1 = _tmp1_;
	_tmp2_ = g_str_has_prefix (name1, "/dev/pts/");
	g_assert (_tmp2_);
	_tmp3_ = fso_framework_pty_transport_new ();
	t2 = _tmp3_;
	fso_framework_transport_open ((FsoFrameworkTransport*) t2);
	_tmp4_ = fso_framework_transport_getName ((FsoFrameworkTransport*) t2);
	name2 = _tmp4_;
	_tmp5_ = g_str_has_prefix (name2, "/dev/pts/");
	g_assert (_tmp5_);
	g_assert (g_strcmp0 (name1, name2) != 0);
	fso_framework_transport_close ((FsoFrameworkTransport*) t2);
	fso_framework_transport_close ((FsoFrameworkTransport*) t1);
	_g_free0 (name2);
	_g_object_unref0 (t2);
	_g_free0 (name1);
	_g_object_unref0 (t1);
}


void test_transport_pty_write (void) {
	FsoFrameworkPtyTransport* _tmp0_;
	FsoFrameworkPtyTransport* t;
	GMainLoop* _tmp1_;
	GMainLoop* loop;
	GMainContext* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gint _tmp5_ = 0;
	gint _tmp6_;
	gint fd;
	gchar* _tmp7_ = NULL;
	gchar* buf;
	gint buf_length1;
	gint _buf_size_;
	gssize _tmp8_ = 0L;
	gssize length;
	gchar _tmp9_;
	gint _tmp10_ = 0;
	_tmp0_ = fso_framework_pty_transport_new ();
	t = _tmp0_;
	fso_framework_transport_open ((FsoFrameworkTransport*) t);
	fso_framework_transport_write ((FsoFrameworkTransport*) t, TRANSPORT_TEST_STRING, G_N_ELEMENTS (TRANSPORT_TEST_STRING));
	_tmp1_ = g_main_loop_new (NULL, FALSE);
	loop = _tmp1_;
	_tmp2_ = g_main_context_default ();
	g_main_context_iteration (_tmp2_, FALSE);
	_tmp3_ = fso_framework_transport_getName ((FsoFrameworkTransport*) t);
	_tmp4_ = _tmp3_;
	_tmp5_ = open (_tmp4_, O_RDONLY, (mode_t) 0);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	fd = _tmp6_;
	g_assert (fd != (-1));
	_tmp7_ = g_new0 (gchar, 512);
	buf = _tmp7_;
	buf_length1 = 512;
	_buf_size_ = buf_length1;
	_tmp8_ = read (fd, buf, (gsize) 512);
	length = _tmp8_;
	buf[length] = (gchar) 0;
	_tmp9_ = buf[length];
	g_assert (length == ((gssize) G_N_ELEMENTS (TRANSPORT_TEST_STRING)));
	_tmp10_ = memcmp (TRANSPORT_TEST_STRING, buf, (gsize) G_N_ELEMENTS (TRANSPORT_TEST_STRING));
	g_assert (_tmp10_ == 0);
	buf = (g_free (buf), NULL);
	_g_main_loop_unref0 (loop);
	_g_object_unref0 (t);
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


void test_transport_pty_read (void) {
	gchar* _tmp0_;
	FsoFrameworkPtyTransport* _tmp1_;
	FsoFrameworkPtyTransport* t;
	FsoFrameworkPtyTransport* _tmp2_;
	FsoFrameworkPtyTransport* _tmp3_;
	FsoFrameworkPtyTransport* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gint _tmp7_ = 0;
	gint _tmp8_;
	gint fd;
	gint _tmp9_;
	gint _tmp10_;
	gssize _tmp11_ = 0L;
	gssize written;
	_tmp0_ = g_strdup ("");
	_g_free0 (readline);
	readline = _tmp0_;
	_tmp1_ = fso_framework_pty_transport_new ();
	t = _tmp1_;
	_tmp2_ = t;
	fso_framework_transport_setDelegates ((FsoFrameworkTransport*) _tmp2_, _transport_read_func_fso_framework_transport_func, NULL, _transport_hup_func_fso_framework_transport_func, NULL);
	_tmp3_ = t;
	fso_framework_transport_open ((FsoFrameworkTransport*) _tmp3_);
	_tmp4_ = t;
	_tmp5_ = fso_framework_transport_getName ((FsoFrameworkTransport*) _tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = open (_tmp6_, O_RDWR, (mode_t) 0);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	fd = _tmp8_;
	_tmp9_ = fd;
	g_assert (_tmp9_ != (-1));
	_tmp10_ = fd;
	_tmp11_ = write (_tmp10_, TRANSPORT_READ_STRING, (gsize) G_N_ELEMENTS (TRANSPORT_READ_STRING));
	written = _tmp11_;
	while (TRUE) {
		const gchar* _tmp12_;
		GMainContext* _tmp13_ = NULL;
		_tmp12_ = readline;
		if (!(g_strcmp0 (_tmp12_, "") == 0)) {
			break;
		}
		_tmp13_ = g_main_context_default ();
		g_main_context_iteration (_tmp13_, FALSE);
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp14_;
			_tmp14_ = TRUE;
			while (TRUE) {
				gboolean _tmp15_;
				gint _tmp17_;
				const gchar* _tmp18_;
				gint _tmp19_;
				gchar _tmp20_ = '\0';
				gint _tmp21_;
				gchar _tmp22_;
				_tmp15_ = _tmp14_;
				if (!_tmp15_) {
					gint _tmp16_;
					_tmp16_ = i;
					i = _tmp16_ + 1;
				}
				_tmp14_ = FALSE;
				_tmp17_ = i;
				if (!(_tmp17_ < G_N_ELEMENTS (TRANSPORT_READ_STRING))) {
					break;
				}
				_tmp18_ = readline;
				_tmp19_ = i;
				_tmp20_ = string_get (_tmp18_, (glong) _tmp19_);
				_tmp21_ = i;
				_tmp22_ = TRANSPORT_READ_STRING[_tmp21_];
				g_assert (_tmp20_ == _tmp22_);
			}
		}
	}
	_g_object_unref0 (t);
}


void test_transport_pty_hup (void) {
	FsoFrameworkPtyTransport* _tmp0_;
	FsoFrameworkPtyTransport* t;
	FsoFrameworkPtyTransport* _tmp1_;
	FsoFrameworkPtyTransport* _tmp2_;
	FsoFrameworkPtyTransport* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gint _tmp6_ = 0;
	gint _tmp7_;
	gint fd;
	gint _tmp8_;
	gint _tmp9_;
	FsoFrameworkPtyTransport* _tmp12_;
	gboolean _tmp13_ = FALSE;
	gotHup = FALSE;
	_tmp0_ = fso_framework_pty_transport_new ();
	t = _tmp0_;
	_tmp1_ = t;
	fso_framework_transport_setDelegates ((FsoFrameworkTransport*) _tmp1_, _transport_read_func_fso_framework_transport_func, NULL, _transport_hup_func_fso_framework_transport_func, NULL);
	_tmp2_ = t;
	fso_framework_transport_open ((FsoFrameworkTransport*) _tmp2_);
	_tmp3_ = t;
	_tmp4_ = fso_framework_transport_getName ((FsoFrameworkTransport*) _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = open (_tmp5_, O_RDWR, (mode_t) 0);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	fd = _tmp7_;
	_tmp8_ = fd;
	g_assert (_tmp8_ != (-1));
	_tmp9_ = fd;
	close (_tmp9_);
	while (TRUE) {
		gboolean _tmp10_;
		GMainContext* _tmp11_ = NULL;
		_tmp10_ = gotHup;
		if (!(!_tmp10_)) {
			break;
		}
		_tmp11_ = g_main_context_default ();
		g_main_context_iteration (_tmp11_, FALSE);
	}
	_tmp12_ = t;
	_tmp13_ = fso_framework_transport_isOpen ((FsoFrameworkTransport*) _tmp12_);
	g_assert (!_tmp13_);
	_g_object_unref0 (t);
}


void test_transport_pty_freeze_thaw (void) {
	FsoFrameworkPtyTransport* _tmp0_;
	FsoFrameworkPtyTransport* t;
	FsoFrameworkPtyTransport* _tmp1_;
	FsoFrameworkPtyTransport* _tmp2_;
	gchar* _tmp3_;
	FsoFrameworkPtyTransport* _tmp4_;
	FsoFrameworkPtyTransport* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_;
	gint fd;
	gint _tmp10_;
	gint _tmp11_;
	gssize _tmp12_ = 0L;
	gssize written;
	GMainContext* _tmp13_ = NULL;
	GMainContext* _tmp14_ = NULL;
	GMainContext* _tmp15_ = NULL;
	FsoFrameworkPtyTransport* _tmp16_;
	const gchar* _tmp19_;
	_tmp0_ = fso_framework_pty_transport_new ();
	t = _tmp0_;
	_tmp1_ = t;
	fso_framework_transport_setDelegates ((FsoFrameworkTransport*) _tmp1_, _transport_read_func_fso_framework_transport_func, NULL, _transport_hup_func_fso_framework_transport_func, NULL);
	_tmp2_ = t;
	fso_framework_transport_open ((FsoFrameworkTransport*) _tmp2_);
	_tmp3_ = g_strdup ("");
	_g_free0 (readline);
	readline = _tmp3_;
	_tmp4_ = t;
	fso_framework_transport_freeze ((FsoFrameworkTransport*) _tmp4_);
	frozen = TRUE;
	_tmp5_ = t;
	_tmp6_ = fso_framework_transport_getName ((FsoFrameworkTransport*) _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = open (_tmp7_, O_RDWR, (mode_t) 0);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	fd = _tmp9_;
	_tmp10_ = fd;
	g_assert (_tmp10_ != (-1));
	_tmp11_ = fd;
	_tmp12_ = write (_tmp11_, "HELLO WORLD", (gsize) 11);
	written = _tmp12_;
	_tmp13_ = g_main_context_default ();
	g_main_context_iteration (_tmp13_, FALSE);
	_tmp14_ = g_main_context_default ();
	g_main_context_iteration (_tmp14_, FALSE);
	_tmp15_ = g_main_context_default ();
	g_main_context_iteration (_tmp15_, FALSE);
	frozen = FALSE;
	_tmp16_ = t;
	fso_framework_transport_thaw ((FsoFrameworkTransport*) _tmp16_);
	while (TRUE) {
		const gchar* _tmp17_;
		GMainContext* _tmp18_ = NULL;
		_tmp17_ = readline;
		if (!(g_strcmp0 (_tmp17_, "") == 0)) {
			break;
		}
		_tmp18_ = g_main_context_default ();
		g_main_context_iteration (_tmp18_, FALSE);
	}
	_tmp19_ = readline;
	g_assert (g_strcmp0 (_tmp19_, "HELLO WORLD") == 0);
	_g_object_unref0 (t);
}


void test_transport_spec_from_config (void) {
	FsoFrameworkTransportSpec* _tmp0_ = NULL;
	FsoFrameworkTransportSpec* spec;
	FsoFrameworkTransportSpec* _tmp1_;
	const gchar* _tmp2_;
	FsoFrameworkTransportSpec* _tmp3_;
	const gchar* _tmp4_;
	FsoFrameworkTransportSpec* _tmp5_;
	guint _tmp6_;
	FsoFrameworkTransportSpec* _tmp7_ = NULL;
	FsoFrameworkTransportSpec* _tmp8_;
	const gchar* _tmp9_;
	FsoFrameworkTransportSpec* _tmp10_;
	const gchar* _tmp11_;
	_tmp0_ = fso_framework_transport_spec_parse ("serial:/dev/ttS1:115200");
	spec = _tmp0_;
	_tmp1_ = spec;
	_tmp2_ = _tmp1_->type;
	g_assert (g_strcmp0 (_tmp2_, "serial") == 0);
	_tmp3_ = spec;
	_tmp4_ = _tmp3_->name;
	g_assert (g_strcmp0 (_tmp4_, "/dev/ttS1") == 0);
	_tmp5_ = spec;
	_tmp6_ = _tmp5_->speed;
	g_assert (_tmp6_ == ((guint) 115200));
	_tmp7_ = fso_framework_transport_spec_parse ("combined:[serial:/dev/ttyS1:115200,tcp:192.168.7.2:3001]");
	_fso_framework_transport_spec_unref0 (spec);
	spec = _tmp7_;
	_tmp8_ = spec;
	_tmp9_ = _tmp8_->type;
	g_assert (g_strcmp0 (_tmp9_, "combined") == 0);
	_tmp10_ = spec;
	_tmp11_ = _tmp10_->name;
	g_assert (g_strcmp0 (_tmp11_, "serial:/dev/ttyS1:115200,tcp:192.168.7.2:3001") == 0);
	_fso_framework_transport_spec_unref0 (spec);
}


static void _test_transport_base_gcallback (void) {
	test_transport_base ();
}


static void _test_transport_null_gcallback (void) {
	test_transport_null ();
}


static void _test_transport_serial_gcallback (void) {
	test_transport_serial ();
}


static void _test_transport_pty_gcallback (void) {
	test_transport_pty ();
}


static void _test_transport_pty_write_gcallback (void) {
	test_transport_pty_write ();
}


static void _test_transport_pty_read_gcallback (void) {
	test_transport_pty_read ();
}


static void _test_transport_pty_hup_gcallback (void) {
	test_transport_pty_hup ();
}


static void _test_transport_pty_freeze_thaw_gcallback (void) {
	test_transport_pty_freeze_thaw ();
}


static void _test_transport_spec_from_config_gcallback (void) {
	test_transport_spec_from_config ();
}


void _vala_main (gchar** args, int args_length1) {
	g_test_init (&args_length1, &args, NULL);
	g_test_add_func ("/Transport/Base/*", _test_transport_base_gcallback);
	g_test_add_func ("/Transport/Null/*", _test_transport_null_gcallback);
	g_test_add_func ("/Transport/Serial/OpenClose", _test_transport_serial_gcallback);
	g_test_add_func ("/Transport/Pty/OpenClose", _test_transport_pty_gcallback);
	g_test_add_func ("/Transport/Pty/Write", _test_transport_pty_write_gcallback);
	g_test_add_func ("/Transport/Pty/Read", _test_transport_pty_read_gcallback);
	g_test_add_func ("/Transport/Pty/Hup", _test_transport_pty_hup_gcallback);
	g_test_add_func ("/Transport/Pty/FreezeThaw", _test_transport_pty_freeze_thaw_gcallback);
	g_test_add_func ("/TransportSpec/FromConfig", _test_transport_spec_from_config_gcallback);
	g_test_run ();
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}



