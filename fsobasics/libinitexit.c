/* libinitexit.c generated by valac 0.16.1, the Vala compiler
 * generated from libinitexit.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>


#define FSO_FRAMEWORK_TYPE_LOGGER (fso_framework_logger_get_type ())
#define FSO_FRAMEWORK_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_LOGGER, FsoFrameworkLogger))
#define FSO_FRAMEWORK_IS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_LOGGER))
#define FSO_FRAMEWORK_LOGGER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FSO_FRAMEWORK_TYPE_LOGGER, FsoFrameworkLoggerIface))

typedef struct _FsoFrameworkLogger FsoFrameworkLogger;
typedef struct _FsoFrameworkLoggerIface FsoFrameworkLoggerIface;

#define FSO_FRAMEWORK_TYPE_SMART_KEY_FILE (fso_framework_smart_key_file_get_type ())
#define FSO_FRAMEWORK_SMART_KEY_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_SMART_KEY_FILE, FsoFrameworkSmartKeyFile))
#define FSO_FRAMEWORK_SMART_KEY_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_SMART_KEY_FILE, FsoFrameworkSmartKeyFileClass))
#define FSO_FRAMEWORK_IS_SMART_KEY_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_SMART_KEY_FILE))
#define FSO_FRAMEWORK_IS_SMART_KEY_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_SMART_KEY_FILE))
#define FSO_FRAMEWORK_SMART_KEY_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_SMART_KEY_FILE, FsoFrameworkSmartKeyFileClass))

typedef struct _FsoFrameworkSmartKeyFile FsoFrameworkSmartKeyFile;
typedef struct _FsoFrameworkSmartKeyFileClass FsoFrameworkSmartKeyFileClass;

#define TYPE_GLIB_LOGGER (glib_logger_get_type ())
#define GLIB_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GLIB_LOGGER, GLibLogger))
#define GLIB_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GLIB_LOGGER, GLibLoggerClass))
#define IS_GLIB_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GLIB_LOGGER))
#define IS_GLIB_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GLIB_LOGGER))
#define GLIB_LOGGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GLIB_LOGGER, GLibLoggerClass))

typedef struct _GLibLogger GLibLogger;
typedef struct _GLibLoggerClass GLibLoggerClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

typedef gchar* (*ReprDelegate) (void* user_data);
struct _FsoFrameworkLoggerIface {
	GTypeInterface parent_iface;
	void (*setLevel) (FsoFrameworkLogger* self, GLogLevelFlags level);
	void (*setDestination) (FsoFrameworkLogger* self, const gchar* destination);
	void (*setReprDelegate) (FsoFrameworkLogger* self, ReprDelegate repr, void* repr_target);
	GLogLevelFlags (*getLevel) (FsoFrameworkLogger* self);
	gchar* (*getDestination) (FsoFrameworkLogger* self);
	gboolean (*debug) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*info) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*warning) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*error) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*critical) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*data) (FsoFrameworkLogger* self, guint8* message, int message_length1, gboolean in, GLogLevelFlags when);
};


extern FsoFrameworkLogger* fso_framework_theLogger;
FsoFrameworkLogger* fso_framework_theLogger = NULL;
extern FsoFrameworkSmartKeyFile* fso_framework_theConfig;
FsoFrameworkSmartKeyFile* fso_framework_theConfig = NULL;
extern GLibLogger* fso_framework_glibLogger;
GLibLogger* fso_framework_glibLogger = NULL;

GType fso_framework_logger_get_type (void) G_GNUC_CONST;
GType fso_framework_smart_key_file_get_type (void) G_GNUC_CONST;
GType glib_logger_get_type (void) G_GNUC_CONST;
void fso_framework_onSignal (gint sig);
gboolean fso_framework_logger_error (FsoFrameworkLogger* self, const gchar* message);
gchar** fso_framework_utility_createBacktrace (int* result_length1);
void vala_library_init (void);
gchar* fso_framework_utility_programName (void);
FsoFrameworkSmartKeyFile* fso_framework_smart_key_file_createFromConfig (const gchar* filename);
FsoFrameworkLogger* fso_framework_logger_createFromKeyFile (FsoFrameworkSmartKeyFile* smk, const gchar* group, const gchar* domain);
gboolean fso_framework_smart_key_file_boolValue (FsoFrameworkSmartKeyFile* self, const gchar* section_raw, const gchar* key, gboolean defaultvalue);
GLibLogger* glib_logger_new (FsoFrameworkLogger* logger);
GLibLogger* glib_logger_construct (GType object_type, FsoFrameworkLogger* logger);
gchar** fso_framework_smart_key_file_stringListValue (FsoFrameworkSmartKeyFile* self, const gchar* section_raw, const gchar* key, gchar** defaultvalue, int defaultvalue_length1, int* result_length1);
static void _fso_framework_onSignal_sighandler_t (gint signal);
gboolean fso_framework_logger_debug (FsoFrameworkLogger* self, const gchar* message);
gboolean fso_framework_logger_info (FsoFrameworkLogger* self, const gchar* message);
void vala_library_fini (void);
void silence_unused_warning (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


void fso_framework_onSignal (gint sig) {
	FsoFrameworkLogger* _tmp0_;
	gint _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gint _tmp6_ = 0;
	gchar** _tmp7_ = NULL;
	gchar** bt;
	gint bt_length1;
	gint _bt_size_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gint _tmp19_;
	sighandler_t _tmp20_;
	gint _tmp21_;
	_tmp0_ = fso_framework_theLogger;
	_tmp1_ = sig;
	_tmp2_ = g_strdup_printf ("%i", _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat ("Caught signal ", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	fso_framework_logger_error (_tmp0_, _tmp5_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	_tmp7_ = fso_framework_utility_createBacktrace (&_tmp6_);
	bt = _tmp7_;
	bt_length1 = _tmp6_;
	_bt_size_ = bt_length1;
	_tmp8_ = bt;
	_tmp8__length1 = bt_length1;
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp8_;
		s_collection_length1 = _tmp8__length1;
		for (s_it = 0; s_it < _tmp8__length1; s_it = s_it + 1) {
			gchar* _tmp9_;
			gchar* s = NULL;
			_tmp9_ = g_strdup (s_collection[s_it]);
			s = _tmp9_;
			{
				const gchar* _tmp10_;
				guint8* _tmp11_;
				gint _tmp11__length1;
				guint8* _tmp12_;
				gint _tmp12__length1;
				const gchar* _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				guint8 _tmp16_;
				FsoFrameworkLogger* _tmp17_;
				const gchar* _tmp18_;
				_tmp10_ = s;
				_tmp11_ = string_get_data (_tmp10_, &_tmp11__length1);
				_tmp12_ = _tmp11_;
				_tmp12__length1 = _tmp11__length1;
				_tmp13_ = s;
				_tmp14_ = strlen (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp12_[_tmp15_ - 1] = (guint8) '\0';
				_tmp16_ = _tmp12_[_tmp15_ - 1];
				_tmp17_ = fso_framework_theLogger;
				_tmp18_ = s;
				fso_framework_logger_error (_tmp17_, _tmp18_);
				_g_free0 (s);
			}
		}
	}
	_tmp19_ = sig;
	_tmp20_ = SIG_DFL;
	signal (_tmp19_, _tmp20_);
	_tmp21_ = sig;
	exit (_tmp21_);
	bt = (_vala_array_free (bt, bt_length1, (GDestroyNotify) g_free), NULL);
}


static void _fso_framework_onSignal_sighandler_t (gint signal) {
	fso_framework_onSignal (signal);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


void vala_library_init (void) {
	gchar* _tmp0_ = NULL;
	gchar* bin;
	const gchar* _tmp1_;
	FsoFrameworkSmartKeyFile* _tmp2_ = NULL;
	FsoFrameworkSmartKeyFile* _tmp3_;
	const gchar* _tmp4_;
	FsoFrameworkLogger* _tmp5_ = NULL;
	FsoFrameworkLogger* _tmp6_;
	GType _tmp7_ = 0UL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gchar* classname;
	FsoFrameworkSmartKeyFile* _tmp10_;
	gboolean _tmp11_ = FALSE;
	FsoFrameworkSmartKeyFile* _tmp14_;
	gboolean _tmp15_ = FALSE;
	FsoFrameworkLogger* _tmp34_;
	const gchar* _tmp35_;
	const gchar* _tmp36_ = NULL;
	gchar* _tmp37_ = NULL;
	gchar* _tmp38_;
	_tmp0_ = fso_framework_utility_programName ();
	bin = _tmp0_;
	_tmp1_ = bin;
	_tmp2_ = fso_framework_smart_key_file_createFromConfig (_tmp1_);
	_g_object_unref0 (fso_framework_theConfig);
	fso_framework_theConfig = _tmp2_;
	_tmp3_ = fso_framework_theConfig;
	_tmp4_ = bin;
	_tmp5_ = fso_framework_logger_createFromKeyFile (_tmp3_, "logging", _tmp4_);
	_g_object_unref0 (fso_framework_theLogger);
	fso_framework_theLogger = _tmp5_;
	_tmp6_ = fso_framework_theLogger;
	_tmp7_ = G_TYPE_FROM_INSTANCE (_tmp6_);
	_tmp8_ = g_type_name (_tmp7_);
	_tmp9_ = g_strdup (_tmp8_);
	classname = _tmp9_;
	_tmp10_ = fso_framework_theConfig;
	_tmp11_ = fso_framework_smart_key_file_boolValue (_tmp10_, "logging", "log_integrate_glib", TRUE);
	if (_tmp11_) {
		FsoFrameworkLogger* _tmp12_;
		GLibLogger* _tmp13_;
		_tmp12_ = fso_framework_theLogger;
		_tmp13_ = glib_logger_new (_tmp12_);
		_g_object_unref0 (fso_framework_glibLogger);
		fso_framework_glibLogger = _tmp13_;
	}
	_tmp14_ = fso_framework_theConfig;
	_tmp15_ = fso_framework_smart_key_file_boolValue (_tmp14_, "logging", "log_backtrace", TRUE);
	if (_tmp15_) {
		gint i;
		FsoFrameworkSmartKeyFile* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp18_;
		gchar** _tmp19_ = NULL;
		gchar** _tmp20_;
		gint _tmp20__length1;
		gint _tmp21_ = 0;
		gchar** _tmp22_ = NULL;
		gchar** _tmp23_;
		gint _tmp23__length1;
		FsoFrameworkLogger* _tmp28_;
		gint _tmp29_;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_;
		gchar* _tmp32_ = NULL;
		gchar* _tmp33_;
		i = 0;
		_tmp16_ = fso_framework_theConfig;
		_tmp17_ = g_strdup ("2");
		_tmp18_ = g_strdup ("15");
		_tmp19_ = g_new0 (gchar*, 2 + 1);
		_tmp19_[0] = _tmp17_;
		_tmp19_[1] = _tmp18_;
		_tmp20_ = _tmp19_;
		_tmp20__length1 = 2;
		_tmp22_ = fso_framework_smart_key_file_stringListValue (_tmp16_, "logging", "log_bt_signals", _tmp20_, 2, &_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp23__length1 = _tmp21_;
		_tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL);
		{
			gchar** sig_collection = NULL;
			gint sig_collection_length1 = 0;
			gint _sig_collection_size_ = 0;
			gint sig_it = 0;
			sig_collection = _tmp23_;
			sig_collection_length1 = _tmp23__length1;
			for (sig_it = 0; sig_it < _tmp23__length1; sig_it = sig_it + 1) {
				gchar* _tmp24_;
				gchar* sig = NULL;
				_tmp24_ = g_strdup (sig_collection[sig_it]);
				sig = _tmp24_;
				{
					const gchar* _tmp25_;
					gint _tmp26_ = 0;
					gint _tmp27_;
					_tmp25_ = sig;
					_tmp26_ = atoi (_tmp25_);
					signal (_tmp26_, _fso_framework_onSignal_sighandler_t);
					_tmp27_ = i;
					i = _tmp27_ + 1;
					_g_free0 (sig);
				}
			}
			sig_collection = (_vala_array_free (sig_collection, sig_collection_length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp28_ = fso_framework_theLogger;
		_tmp29_ = i;
		_tmp30_ = g_strdup_printf ("%i", _tmp29_);
		_tmp31_ = _tmp30_;
		_tmp32_ = g_strconcat ("Registered ", _tmp31_, " backtrace handler", NULL);
		_tmp33_ = _tmp32_;
		fso_framework_logger_debug (_tmp28_, _tmp33_);
		_g_free0 (_tmp33_);
		_g_free0 (_tmp31_);
	}
	_tmp34_ = fso_framework_theLogger;
	_tmp35_ = classname;
	_tmp36_ = string_to_string (_tmp35_);
	_tmp37_ = g_strconcat ("Binary launched successful (", _tmp36_, " created as theLogger)", NULL);
	_tmp38_ = _tmp37_;
	fso_framework_logger_info (_tmp34_, _tmp38_);
	_g_free0 (_tmp38_);
	_g_free0 (classname);
	_g_free0 (bin);
}


void vala_library_fini (void) {
	_g_object_unref0 (fso_framework_theConfig);
	fso_framework_theConfig = NULL;
	_g_object_unref0 (fso_framework_theLogger);
	fso_framework_theLogger = NULL;
	_g_object_unref0 (fso_framework_glibLogger);
	fso_framework_glibLogger = NULL;
}


void silence_unused_warning (void) {
	vala_library_fini ();
	vala_library_init ();
	silence_unused_warning ();
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



