/* kobjectnotifier.c generated by valac 0.16.0, the Vala compiler
 * generated from kobjectnotifier.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/netlink.h>

typedef struct _KObjectDelegateHolder KObjectDelegateHolder;

#define FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER (fso_framework_base_kobject_notifier_get_type ())
#define FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER, FsoFrameworkBaseKObjectNotifier))
#define FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER, FsoFrameworkBaseKObjectNotifierClass))
#define FSO_FRAMEWORK_IS_BASE_KOBJECT_NOTIFIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER))
#define FSO_FRAMEWORK_IS_BASE_KOBJECT_NOTIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER))
#define FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER, FsoFrameworkBaseKObjectNotifierClass))

typedef struct _FsoFrameworkBaseKObjectNotifier FsoFrameworkBaseKObjectNotifier;
typedef struct _FsoFrameworkBaseKObjectNotifierClass FsoFrameworkBaseKObjectNotifierClass;
typedef struct _FsoFrameworkBaseKObjectNotifierPrivate FsoFrameworkBaseKObjectNotifierPrivate;
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define FSO_FRAMEWORK_TYPE_LOGGER (fso_framework_logger_get_type ())
#define FSO_FRAMEWORK_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_FRAMEWORK_TYPE_LOGGER, FsoFrameworkLogger))
#define FSO_FRAMEWORK_IS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_FRAMEWORK_TYPE_LOGGER))
#define FSO_FRAMEWORK_LOGGER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FSO_FRAMEWORK_TYPE_LOGGER, FsoFrameworkLoggerIface))

typedef struct _FsoFrameworkLogger FsoFrameworkLogger;
typedef struct _FsoFrameworkLoggerIface FsoFrameworkLoggerIface;
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__kobject_delegate_holder_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__kobject_delegate_holder_free0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

typedef void (*FsoFrameworkKObjectNotifierFunc) (GHashTable* properties, void* user_data);
struct _KObjectDelegateHolder {
	FsoFrameworkKObjectNotifierFunc func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
};

struct _FsoFrameworkBaseKObjectNotifier {
	GObject parent_instance;
	FsoFrameworkBaseKObjectNotifierPrivate * priv;
};

struct _FsoFrameworkBaseKObjectNotifierClass {
	GObjectClass parent_class;
};

struct _FsoFrameworkBaseKObjectNotifierPrivate {
	gint fd;
	guint watch;
	GIOChannel* channel;
	gchar* buffer;
	gint buffer_length1;
	gint _buffer_size_;
	GHashTable* add;
	GHashTable* change;
	GHashTable* remove;
};

typedef gchar* (*ReprDelegate) (void* user_data);
struct _FsoFrameworkLoggerIface {
	GTypeInterface parent_iface;
	void (*setLevel) (FsoFrameworkLogger* self, GLogLevelFlags level);
	void (*setDestination) (FsoFrameworkLogger* self, const gchar* destination);
	void (*setReprDelegate) (FsoFrameworkLogger* self, ReprDelegate repr, void* repr_target);
	GLogLevelFlags (*getLevel) (FsoFrameworkLogger* self);
	gchar* (*getDestination) (FsoFrameworkLogger* self);
	gboolean (*debug) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*info) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*warning) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*error) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*critical) (FsoFrameworkLogger* self, const gchar* message);
	gboolean (*data) (FsoFrameworkLogger* self, guint8* message, int message_length1, gboolean in, GLogLevelFlags when);
};


static gpointer fso_framework_base_kobject_notifier_parent_class = NULL;
extern FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_instance;
FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_instance = NULL;
extern FsoFrameworkLogger* fso_framework_theLogger;

void kobject_delegate_holder_free (KObjectDelegateHolder* self);
static void kobject_delegate_holder_instance_init (KObjectDelegateHolder * self);
KObjectDelegateHolder* kobject_delegate_holder_new (FsoFrameworkKObjectNotifierFunc func, void* func_target);
KObjectDelegateHolder* kobject_delegate_holder_new (FsoFrameworkKObjectNotifierFunc func, void* func_target);
GType fso_framework_base_kobject_notifier_get_type (void) G_GNUC_CONST;
#define FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER, FsoFrameworkBaseKObjectNotifierPrivate))
enum  {
	FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_DUMMY_PROPERTY
};
#define FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_BUFFER_LENGTH ((gssize) 4096)
FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_new (void);
FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_construct (GType object_type);
static void _g_free0_ (gpointer var);
static void _kobject_delegate_holder_free0_ (gpointer var);
static void _g_list_free__kobject_delegate_holder_free0_ (GList* self);
static void __g_list_free__kobject_delegate_holder_free0_0_ (gpointer var);
gboolean fso_framework_base_kobject_notifier_onActionFromSocket (FsoFrameworkBaseKObjectNotifier* self, GIOChannel* source, GIOCondition condition);
static gboolean _fso_framework_base_kobject_notifier_onActionFromSocket_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
GType fso_framework_logger_get_type (void) G_GNUC_CONST;
gboolean fso_framework_logger_error (FsoFrameworkLogger* self, const gchar* message);
void fso_framework_base_kobject_notifier_handleMessage (FsoFrameworkBaseKObjectNotifier* self, gchar** parts, int parts_length1);
gboolean fso_framework_logger_warning (FsoFrameworkLogger* self, const gchar* message);
void _fso_framework_base_kobject_notifier_addMatch (FsoFrameworkBaseKObjectNotifier* self, const gchar* action, const gchar* subsystem, FsoFrameworkKObjectNotifierFunc callback, void* callback_target);
void fso_framework_base_kobject_notifier_addMatch (const gchar* action, const gchar* subsystem, FsoFrameworkKObjectNotifierFunc callback, void* callback_target);
static void fso_framework_base_kobject_notifier_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


KObjectDelegateHolder* kobject_delegate_holder_new (FsoFrameworkKObjectNotifierFunc func, void* func_target) {
	KObjectDelegateHolder* self;
	FsoFrameworkKObjectNotifierFunc _tmp0_;
	void* _tmp0__target;
	self = g_slice_new0 (KObjectDelegateHolder);
	kobject_delegate_holder_instance_init (self);
	_tmp0_ = func;
	_tmp0__target = func_target;
	(self->func_target_destroy_notify == NULL) ? NULL : (self->func_target_destroy_notify (self->func_target), NULL);
	self->func = NULL;
	self->func_target = NULL;
	self->func_target_destroy_notify = NULL;
	self->func = _tmp0_;
	self->func_target = _tmp0__target;
	self->func_target_destroy_notify = NULL;
	return self;
}


static void kobject_delegate_holder_instance_init (KObjectDelegateHolder * self) {
}


void kobject_delegate_holder_free (KObjectDelegateHolder* self) {
	(self->func_target_destroy_notify == NULL) ? NULL : (self->func_target_destroy_notify (self->func_target), NULL);
	self->func = NULL;
	self->func_target = NULL;
	self->func_target_destroy_notify = NULL;
	g_slice_free (KObjectDelegateHolder, self);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _kobject_delegate_holder_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (kobject_delegate_holder_free (var), NULL));
}


static void _g_list_free__kobject_delegate_holder_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _kobject_delegate_holder_free0_, NULL);
	g_list_free (self);
}


static void __g_list_free__kobject_delegate_holder_free0_0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (_g_list_free__kobject_delegate_holder_free0_ (var), NULL));
}


static gboolean _fso_framework_base_kobject_notifier_onActionFromSocket_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = fso_framework_base_kobject_notifier_onActionFromSocket (self, source, condition);
	return result;
}


FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_construct (GType object_type) {
	FsoFrameworkBaseKObjectNotifier * self = NULL;
	gchar* _tmp0_ = NULL;
	GHashFunc _tmp1_;
	GEqualFunc _tmp2_;
	GHashTable* _tmp3_;
	GHashFunc _tmp4_;
	GEqualFunc _tmp5_;
	GHashTable* _tmp6_;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GHashTable* _tmp9_;
	gint _tmp10_ = 0;
	gint _tmp11_;
	pid_t _tmp12_ = 0;
	struct sockaddr_nl _tmp13_ = {0};
	struct sockaddr_nl addr;
	gint _tmp14_;
	gint _tmp15_ = 0;
	gint res;
	gint _tmp16_;
	GIOChannel* _tmp17_;
	GIOChannel* _tmp18_;
	guint _tmp19_ = 0U;
	self = (FsoFrameworkBaseKObjectNotifier*) g_object_new (object_type, NULL);
	_tmp0_ = g_new0 (gchar, FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_BUFFER_LENGTH);
	self->priv->buffer = (g_free (self->priv->buffer), NULL);
	self->priv->buffer = _tmp0_;
	self->priv->buffer_length1 = FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_BUFFER_LENGTH;
	self->priv->_buffer_size_ = self->priv->buffer_length1;
	_tmp1_ = g_str_hash;
	_tmp2_ = g_str_equal;
	_tmp3_ = g_hash_table_new_full (_tmp1_, _tmp2_, _g_free0_, __g_list_free__kobject_delegate_holder_free0_0_);
	_g_hash_table_unref0 (self->priv->add);
	self->priv->add = _tmp3_;
	_tmp4_ = g_str_hash;
	_tmp5_ = g_str_equal;
	_tmp6_ = g_hash_table_new_full (_tmp4_, _tmp5_, _g_free0_, __g_list_free__kobject_delegate_holder_free0_0_);
	_g_hash_table_unref0 (self->priv->change);
	self->priv->change = _tmp6_;
	_tmp7_ = g_str_hash;
	_tmp8_ = g_str_equal;
	_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_free0_, __g_list_free__kobject_delegate_holder_free0_0_);
	_g_hash_table_unref0 (self->priv->remove);
	self->priv->remove = _tmp9_;
	_tmp10_ = socket (AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
	self->priv->fd = _tmp10_;
	_tmp11_ = self->priv->fd;
	g_assert (_tmp11_ != (-1));
	_tmp12_ = getpid ();
	_tmp13_.nl_family = AF_NETLINK;
	_tmp13_.nl_pad = (gushort) 0;
	_tmp13_.nl_pid = (guint32) _tmp12_;
	_tmp13_.nl_groups = (guint32) 1;
	addr = _tmp13_;
	_tmp14_ = self->priv->fd;
	_tmp15_ = bind (_tmp14_, (void*) (&addr), sizeof (struct sockaddr_nl));
	res = _tmp15_;
	g_assert (res != (-1));
	_tmp16_ = self->priv->fd;
	_tmp17_ = g_io_channel_unix_new (_tmp16_);
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->channel = _tmp17_;
	_tmp18_ = self->priv->channel;
	_tmp19_ = g_io_add_watch (_tmp18_, G_IO_IN | G_IO_HUP, _fso_framework_base_kobject_notifier_onActionFromSocket_gio_func, self);
	self->priv->watch = _tmp19_;
	 (&addr);
	return self;
}


FsoFrameworkBaseKObjectNotifier* fso_framework_base_kobject_notifier_new (void) {
	return fso_framework_base_kobject_notifier_construct (FSO_FRAMEWORK_TYPE_BASE_KOBJECT_NOTIFIER);
}


gboolean fso_framework_base_kobject_notifier_onActionFromSocket (FsoFrameworkBaseKObjectNotifier* self, GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	GIOCondition _tmp0_;
	GIOCondition _tmp2_;
	GIOCondition _tmp23_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	_tmp0_ = condition;
	if ((_tmp0_ & G_IO_HUP) == G_IO_HUP) {
		FsoFrameworkLogger* _tmp1_;
		_tmp1_ = fso_framework_theLogger;
		fso_framework_logger_error (_tmp1_, "HUP on kobject uevent socket, will no longer get any notifications");
		result = FALSE;
		return result;
	}
	_tmp2_ = condition;
	if ((_tmp2_ & G_IO_IN) == G_IO_IN) {
		gint _tmp3_;
		gchar* _tmp4_;
		gint _tmp4__length1;
		gint _tmp5_;
		gchar* _tmp6_;
		gint _tmp6__length1;
		gssize _tmp7_ = 0L;
		gssize bytesread;
		gchar* _tmp19_;
		gint _tmp19__length1;
		gchar** _tmp20_;
		gchar** _tmp21_ = NULL;
		gchar** parts;
		gint parts_length1;
		gint _parts_size_;
		gchar** _tmp22_;
		gint _tmp22__length1;
		_tmp3_ = self->priv->fd;
		g_assert (_tmp3_ != (-1));
		_tmp4_ = self->priv->buffer;
		_tmp4__length1 = self->priv->buffer_length1;
		g_assert (_tmp4_ != NULL);
		_tmp5_ = self->priv->fd;
		_tmp6_ = self->priv->buffer;
		_tmp6__length1 = self->priv->buffer_length1;
		_tmp7_ = read (_tmp5_, _tmp6_, (gsize) FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_BUFFER_LENGTH);
		bytesread = _tmp7_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp8_;
				_tmp8_ = TRUE;
				while (TRUE) {
					gboolean _tmp9_;
					gint _tmp11_;
					gssize _tmp12_;
					gchar* _tmp13_;
					gint _tmp13__length1;
					gint _tmp14_;
					gchar _tmp15_;
					_tmp9_ = _tmp8_;
					if (!_tmp9_) {
						gint _tmp10_;
						_tmp10_ = i;
						i = _tmp10_ + 1;
					}
					_tmp8_ = FALSE;
					_tmp11_ = i;
					_tmp12_ = bytesread;
					if (!(((gssize) _tmp11_) < (_tmp12_ - 1))) {
						break;
					}
					_tmp13_ = self->priv->buffer;
					_tmp13__length1 = self->priv->buffer_length1;
					_tmp14_ = i;
					_tmp15_ = _tmp13_[_tmp14_];
					if (((gint) _tmp15_) == 0x00) {
						gchar* _tmp16_;
						gint _tmp16__length1;
						gint _tmp17_;
						gchar _tmp18_;
						_tmp16_ = self->priv->buffer;
						_tmp16__length1 = self->priv->buffer_length1;
						_tmp17_ = i;
						_tmp16_[_tmp17_] = (gchar) 0x09;
						_tmp18_ = _tmp16_[_tmp17_];
					}
				}
			}
		}
		_tmp19_ = self->priv->buffer;
		_tmp19__length1 = self->priv->buffer_length1;
		_tmp21_ = _tmp20_ = g_strsplit ((const gchar*) _tmp19_, "\t", 0);
		parts = _tmp21_;
		parts_length1 = _vala_array_length (_tmp20_);
		_parts_size_ = parts_length1;
		_tmp22_ = parts;
		_tmp22__length1 = parts_length1;
		fso_framework_base_kobject_notifier_handleMessage (self, _tmp22_, _tmp22__length1);
		result = TRUE;
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp23_ = condition;
	g_critical ("kobjectnotifier.vala:108: Unsupported IOCondition %u", (guint) ((gint) _tmp23_));
	result = TRUE;
	return result;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


void fso_framework_base_kobject_notifier_handleMessage (FsoFrameworkBaseKObjectNotifier* self, gchar** parts, int parts_length1) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* properties;
	gchar** _tmp3_;
	gint _tmp3__length1;
	GHashTable* _tmp16_;
	gconstpointer _tmp17_ = NULL;
	gchar* _tmp18_;
	gchar* action;
	const gchar* _tmp19_;
	GHashTable* _tmp20_;
	gconstpointer _tmp21_ = NULL;
	gchar* _tmp22_;
	gchar* subsystem;
	const gchar* _tmp23_;
	GHashTable* table;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	GQuark _tmp27_ = 0U;
	static GQuark _tmp26_label0 = 0;
	static GQuark _tmp26_label1 = 0;
	static GQuark _tmp26_label2 = 0;
	GHashTable* _tmp39_;
	const gchar* _tmp40_;
	gconstpointer _tmp41_ = NULL;
	GList* list;
	GList* _tmp42_;
	GList* _tmp43_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_free0_);
	properties = _tmp2_;
	_tmp3_ = parts;
	_tmp3__length1 = parts_length1;
	{
		gchar** part_collection = NULL;
		gint part_collection_length1 = 0;
		gint _part_collection_size_ = 0;
		gint part_it = 0;
		part_collection = _tmp3_;
		part_collection_length1 = _tmp3__length1;
		for (part_it = 0; part_it < _tmp3__length1; part_it = part_it + 1) {
			gchar* _tmp4_;
			gchar* part = NULL;
			_tmp4_ = g_strdup (part_collection[part_it]);
			part = _tmp4_;
			{
				const gchar* _tmp5_;
				gchar** _tmp6_;
				gchar** _tmp7_ = NULL;
				gchar** elements;
				gint elements_length1;
				gint _elements_size_;
				gchar** _tmp8_;
				gint _tmp8__length1;
				_tmp5_ = part;
				_tmp7_ = _tmp6_ = g_strsplit (_tmp5_, "=", 0);
				elements = _tmp7_;
				elements_length1 = _vala_array_length (_tmp6_);
				_elements_size_ = elements_length1;
				_tmp8_ = elements;
				_tmp8__length1 = elements_length1;
				if (_tmp8__length1 == 2) {
					GHashTable* _tmp9_;
					gchar** _tmp10_;
					gint _tmp10__length1;
					const gchar* _tmp11_;
					gchar* _tmp12_;
					gchar** _tmp13_;
					gint _tmp13__length1;
					const gchar* _tmp14_;
					gchar* _tmp15_;
					_tmp9_ = properties;
					_tmp10_ = elements;
					_tmp10__length1 = elements_length1;
					_tmp11_ = _tmp10_[0];
					_tmp12_ = g_strdup (_tmp11_);
					_tmp13_ = elements;
					_tmp13__length1 = elements_length1;
					_tmp14_ = _tmp13_[1];
					_tmp15_ = g_strdup (_tmp14_);
					g_hash_table_insert (_tmp9_, _tmp12_, _tmp15_);
				}
				elements = (_vala_array_free (elements, elements_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (part);
			}
		}
	}
	_tmp16_ = properties;
	_tmp17_ = g_hash_table_lookup (_tmp16_, "ACTION");
	_tmp18_ = g_strdup ((const gchar*) _tmp17_);
	action = _tmp18_;
	_tmp19_ = action;
	g_assert (_tmp19_ != NULL);
	_tmp20_ = properties;
	_tmp21_ = g_hash_table_lookup (_tmp20_, "SUBSYSTEM");
	_tmp22_ = g_strdup ((const gchar*) _tmp21_);
	subsystem = _tmp22_;
	_tmp23_ = subsystem;
	g_assert (_tmp23_ != NULL);
	table = NULL;
	_tmp24_ = action;
	_tmp25_ = _tmp24_;
	_tmp27_ = (NULL == _tmp25_) ? 0 : g_quark_from_string (_tmp25_);
	if (_tmp27_ == ((0 != _tmp26_label0) ? _tmp26_label0 : (_tmp26_label0 = g_quark_from_static_string ("add")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp28_;
				GHashTable* _tmp29_;
				_tmp28_ = self->priv->add;
				_tmp29_ = _g_hash_table_ref0 (_tmp28_);
				_g_hash_table_unref0 (table);
				table = _tmp29_;
				break;
			}
		}
	} else if (_tmp27_ == ((0 != _tmp26_label1) ? _tmp26_label1 : (_tmp26_label1 = g_quark_from_static_string ("change")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp30_;
				GHashTable* _tmp31_;
				_tmp30_ = self->priv->change;
				_tmp31_ = _g_hash_table_ref0 (_tmp30_);
				_g_hash_table_unref0 (table);
				table = _tmp31_;
				break;
			}
		}
	} else if (_tmp27_ == ((0 != _tmp26_label2) ? _tmp26_label2 : (_tmp26_label2 = g_quark_from_static_string ("remove")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp32_;
				GHashTable* _tmp33_;
				_tmp32_ = self->priv->remove;
				_tmp33_ = _g_hash_table_ref0 (_tmp32_);
				_g_hash_table_unref0 (table);
				table = _tmp33_;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				FsoFrameworkLogger* _tmp34_;
				const gchar* _tmp35_;
				const gchar* _tmp36_ = NULL;
				gchar* _tmp37_ = NULL;
				gchar* _tmp38_;
				_tmp34_ = fso_framework_theLogger;
				_tmp35_ = action;
				_tmp36_ = string_to_string (_tmp35_);
				_tmp37_ = g_strconcat ("Unsupported kobject message action ", _tmp36_, ", must be one of { add, change, remove }", NULL);
				_tmp38_ = _tmp37_;
				fso_framework_logger_warning (_tmp34_, _tmp38_);
				_g_free0 (_tmp38_);
				break;
			}
		}
	}
	_tmp39_ = table;
	_tmp40_ = subsystem;
	_tmp41_ = g_hash_table_lookup (_tmp39_, _tmp40_);
	list = (GList*) _tmp41_;
	_tmp42_ = list;
	if (_tmp42_ == NULL) {
		_g_hash_table_unref0 (table);
		_g_free0 (subsystem);
		_g_free0 (action);
		_g_hash_table_unref0 (properties);
		return;
	}
	_tmp43_ = list;
	{
		GList* delegateholder_collection = NULL;
		GList* delegateholder_it = NULL;
		delegateholder_collection = _tmp43_;
		for (delegateholder_it = delegateholder_collection; delegateholder_it != NULL; delegateholder_it = delegateholder_it->next) {
			KObjectDelegateHolder* delegateholder = NULL;
			delegateholder = (KObjectDelegateHolder*) delegateholder_it->data;
			{
				KObjectDelegateHolder* _tmp44_;
				FsoFrameworkKObjectNotifierFunc _tmp45_;
				void* _tmp45__target;
				GHashTable* _tmp46_;
				_tmp44_ = delegateholder;
				_tmp45_ = _tmp44_->func;
				_tmp45__target = _tmp44_->func_target;
				_tmp46_ = properties;
				_tmp45_ (_tmp46_, _tmp45__target);
			}
		}
	}
	_g_hash_table_unref0 (table);
	_g_free0 (subsystem);
	_g_free0 (action);
	_g_hash_table_unref0 (properties);
}


void _fso_framework_base_kobject_notifier_addMatch (FsoFrameworkBaseKObjectNotifier* self, const gchar* action, const gchar* subsystem, FsoFrameworkKObjectNotifierFunc callback, void* callback_target) {
	GHashTable* table;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	GHashTable* _tmp15_;
	const gchar* _tmp16_;
	gconstpointer _tmp17_ = NULL;
	GList* list;
	GList* _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (subsystem != NULL);
	table = NULL;
	_tmp0_ = action;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("add")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp4_;
				GHashTable* _tmp5_;
				_tmp4_ = self->priv->add;
				_tmp5_ = _g_hash_table_ref0 (_tmp4_);
				_g_hash_table_unref0 (table);
				table = _tmp5_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("change")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp6_;
				GHashTable* _tmp7_;
				_tmp6_ = self->priv->change;
				_tmp7_ = _g_hash_table_ref0 (_tmp6_);
				_g_hash_table_unref0 (table);
				table = _tmp7_;
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("remove")))) {
		switch (0) {
			default:
			{
				GHashTable* _tmp8_;
				GHashTable* _tmp9_;
				_tmp8_ = self->priv->remove;
				_tmp9_ = _g_hash_table_ref0 (_tmp8_);
				_g_hash_table_unref0 (table);
				table = _tmp9_;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				FsoFrameworkLogger* _tmp10_;
				const gchar* _tmp11_;
				const gchar* _tmp12_ = NULL;
				gchar* _tmp13_ = NULL;
				gchar* _tmp14_;
				_tmp10_ = fso_framework_theLogger;
				_tmp11_ = action;
				_tmp12_ = string_to_string (_tmp11_);
				_tmp13_ = g_strconcat ("Unsupported action ", _tmp12_, " in _addMatch, must be one of { add, change, remove }", NULL);
				_tmp14_ = _tmp13_;
				fso_framework_logger_warning (_tmp10_, _tmp14_);
				_g_free0 (_tmp14_);
				break;
			}
		}
	}
	_tmp15_ = table;
	_tmp16_ = subsystem;
	_tmp17_ = g_hash_table_lookup (_tmp15_, _tmp16_);
	list = (GList*) _tmp17_;
	_tmp18_ = list;
	if (_tmp18_ == NULL) {
		GList* newlist;
		FsoFrameworkKObjectNotifierFunc _tmp19_;
		void* _tmp19__target;
		KObjectDelegateHolder* _tmp20_;
		GHashTable* _tmp21_;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		GList* _tmp24_;
		newlist = NULL;
		_tmp19_ = callback;
		_tmp19__target = callback_target;
		_tmp20_ = kobject_delegate_holder_new (_tmp19_, _tmp19__target);
		newlist = g_list_append (newlist, _tmp20_);
		_tmp21_ = table;
		_tmp22_ = subsystem;
		_tmp23_ = g_strdup (_tmp22_);
		_tmp24_ = newlist;
		newlist = NULL;
		g_hash_table_insert (_tmp21_, _tmp23_, _tmp24_);
		__g_list_free__kobject_delegate_holder_free0_0 (newlist);
	} else {
		FsoFrameworkKObjectNotifierFunc _tmp25_;
		void* _tmp25__target;
		KObjectDelegateHolder* _tmp26_;
		_tmp25_ = callback;
		_tmp25__target = callback_target;
		_tmp26_ = kobject_delegate_holder_new (_tmp25_, _tmp25__target);
		list = g_list_append (list, _tmp26_);
	}
	_g_hash_table_unref0 (table);
}


void fso_framework_base_kobject_notifier_addMatch (const gchar* action, const gchar* subsystem, FsoFrameworkKObjectNotifierFunc callback, void* callback_target) {
	FsoFrameworkBaseKObjectNotifier* _tmp0_;
	FsoFrameworkBaseKObjectNotifier* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	FsoFrameworkKObjectNotifierFunc _tmp5_;
	void* _tmp5__target;
	g_return_if_fail (action != NULL);
	g_return_if_fail (subsystem != NULL);
	_tmp0_ = fso_framework_base_kobject_notifier_instance;
	if (_tmp0_ == NULL) {
		FsoFrameworkBaseKObjectNotifier* _tmp1_;
		_tmp1_ = fso_framework_base_kobject_notifier_new ();
		_g_object_unref0 (fso_framework_base_kobject_notifier_instance);
		fso_framework_base_kobject_notifier_instance = _tmp1_;
	}
	_tmp2_ = fso_framework_base_kobject_notifier_instance;
	_tmp3_ = action;
	_tmp4_ = subsystem;
	_tmp5_ = callback;
	_tmp5__target = callback_target;
	_fso_framework_base_kobject_notifier_addMatch (_tmp2_, _tmp3_, _tmp4_, _tmp5_, _tmp5__target);
}


static void fso_framework_base_kobject_notifier_class_init (FsoFrameworkBaseKObjectNotifierClass * klass) {
	fso_framework_base_kobject_notifier_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoFrameworkBaseKObjectNotifierPrivate));
	G_OBJECT_CLASS (klass)->finalize = fso_framework_base_kobject_notifier_finalize;
}


static void fso_framework_base_kobject_notifier_instance_init (FsoFrameworkBaseKObjectNotifier * self) {
	self->priv = FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER_GET_PRIVATE (self);
	self->priv->fd = -1;
}


static void fso_framework_base_kobject_notifier_finalize (GObject* obj) {
	FsoFrameworkBaseKObjectNotifier * self;
	guint _tmp0_;
	gint _tmp2_;
	self = FSO_FRAMEWORK_BASE_KOBJECT_NOTIFIER (obj);
	_tmp0_ = self->priv->watch;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->watch;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = self->priv->fd;
	if (_tmp2_ != (-1)) {
		gint _tmp3_;
		_tmp3_ = self->priv->fd;
		close (_tmp3_);
	}
	_g_io_channel_unref0 (self->priv->channel);
	self->priv->buffer = (g_free (self->priv->buffer), NULL);
	_g_hash_table_unref0 (self->priv->add);
	_g_hash_table_unref0 (self->priv->change);
	_g_hash_table_unref0 (self->priv->remove);
	G_OBJECT_CLASS (fso_framework_base_kobject_notifier_parent_class)->finalize (obj);
}


/**
 * @class FsoFramework.BaseKObjectNotifier
 **/
GType fso_framework_base_kobject_notifier_get_type (void) {
	static volatile gsize fso_framework_base_kobject_notifier_type_id__volatile = 0;
	if (g_once_init_enter (&fso_framework_base_kobject_notifier_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoFrameworkBaseKObjectNotifierClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_framework_base_kobject_notifier_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoFrameworkBaseKObjectNotifier), 0, (GInstanceInitFunc) fso_framework_base_kobject_notifier_instance_init, NULL };
		GType fso_framework_base_kobject_notifier_type_id;
		fso_framework_base_kobject_notifier_type_id = g_type_register_static (G_TYPE_OBJECT, "FsoFrameworkBaseKObjectNotifier", &g_define_type_info, 0);
		g_once_init_leave (&fso_framework_base_kobject_notifier_type_id__volatile, fso_framework_base_kobject_notifier_type_id);
	}
	return fso_framework_base_kobject_notifier_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



