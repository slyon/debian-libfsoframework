/* netlinkutils.c generated by valac 0.16.1, the Vala compiler
 * generated from netlinkutils.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <netlink/netlink.h>
#include <linux/netlink.h>
#include <sys/socket.h>
#include <netlink/route/addr.h>
#include <netlink/object.h>
#include <arpa/inet.h>

typedef struct _Block2Data Block2Data;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _nl_cache_free0(var) ((var == NULL) ? NULL : (var = (nl_cache_free (var), NULL)))
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _nl_socket_free0(var) ((var == NULL) ? NULL : (var = (nl_socket_free (var), NULL)))

struct _Block2Data {
	int _ref_count_;
	gchar* ipv4;
};



gchar* fso_framework_net_ipv4AddressForInterface (const gchar* iface);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda3_ (Block2Data* _data2_, struct nl_object* element);
static void ___lambda3__netlink_callback_func (struct nl_object* obj, gpointer self);


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_free0 (_data2_->ipv4);
		g_slice_free (Block2Data, _data2_);
	}
}


static void __lambda3_ (Block2Data* _data2_, struct nl_object* element) {
	struct nl_object* _tmp0_;
	struct nl_addr* _tmp1_ = NULL;
	struct nl_addr* addr;
	struct nl_addr* _tmp2_;
	gint _tmp3_ = 0;
	g_return_if_fail (element != NULL);
	_tmp0_ = element;
	_tmp1_ = rtnl_addr_get_local ((struct rtnl_addr*) _tmp0_);
	addr = _tmp1_;
	_tmp2_ = addr;
	_tmp3_ = nl_addr_get_len (_tmp2_);
	if (_tmp3_ == 4) {
		struct nl_addr* _tmp4_;
		void* _tmp5_ = NULL;
		guint32 binaddress;
		struct in_addr inaddr = {0};
		guint32 _tmp6_;
		guint32 _tmp7_ = 0U;
		struct in_addr _tmp8_;
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp4_ = addr;
		_tmp5_ = nl_addr_get_binary_addr (_tmp4_);
		binaddress = *((guint32*) _tmp5_);
		memset (&inaddr, 0, sizeof (struct in_addr));
		_tmp6_ = binaddress;
		_tmp7_ = ntohl (_tmp6_);
		inaddr.s_addr = _tmp7_;
		_tmp8_ = inaddr;
		_tmp9_ = inet_ntoa ((struct in_addr) _tmp8_);
		_tmp10_ = g_strdup (_tmp9_);
		_g_free0 (_data2_->ipv4);
		_data2_->ipv4 = _tmp10_;
		 (&inaddr);
	}
}


static void ___lambda3__netlink_callback_func (struct nl_object* obj, gpointer self) {
	__lambda3_ (self, obj);
}


gchar* fso_framework_net_ipv4AddressForInterface (const gchar* iface) {
	gchar* result = NULL;
	Block2Data* _data2_;
	struct nl_sock* _tmp0_;
	struct nl_sock* socket;
	struct nl_cache* link_cache = NULL;
	struct nl_cache* _tmp1_ = NULL;
	struct nl_cache* addr_cache = NULL;
	struct nl_cache* _tmp2_ = NULL;
	const gchar* _tmp3_;
	gint _tmp4_ = 0;
	gint ifindex;
	struct rtnl_addr* _tmp5_;
	struct rtnl_addr* routeaddr;
	gchar* _tmp6_;
	gchar* _tmp7_;
	g_return_val_if_fail (iface != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = nl_socket_alloc ();
	socket = _tmp0_;
	nl_connect (socket, NETLINK_ROUTE);
	rtnl_link_alloc_cache (socket, AF_UNSPEC, &_tmp1_);
	_nl_cache_free0 (link_cache);
	link_cache = _tmp1_;
	rtnl_addr_alloc_cache (socket, &_tmp2_);
	_nl_cache_free0 (addr_cache);
	addr_cache = _tmp2_;
	_tmp3_ = iface;
	_tmp4_ = rtnl_link_name2i (link_cache, _tmp3_);
	ifindex = _tmp4_;
	_tmp5_ = rtnl_addr_alloc ();
	routeaddr = _tmp5_;
	rtnl_addr_set_ifindex (routeaddr, ifindex);
	_tmp6_ = g_strdup ("unknown");
	_data2_->ipv4 = _tmp6_;
	nl_cache_foreach_filter (addr_cache, (struct nl_object*) routeaddr, ___lambda3__netlink_callback_func, _data2_);
	rtnl_addr_put ((struct nl_addr*) routeaddr);
	_tmp7_ = g_strdup (_data2_->ipv4);
	result = _tmp7_;
	_0 (routeaddr);
	_nl_cache_free0 (addr_cache);
	_nl_cache_free0 (link_cache);
	_nl_socket_free0 (socket);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}



