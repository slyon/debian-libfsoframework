/* stringhandling.c generated by valac 0.16.1, the Vala compiler
 * generated from stringhandling.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _t_destroy_func0(var) (((var == NULL) || (t_destroy_func == NULL)) ? NULL : (var = (t_destroy_func (var), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))


extern GRegex* _keyValueRe;
GRegex* _keyValueRe = NULL;

gchar* fso_framework_string_handling_stringListToString (gchar** list, int list_length1);
gpointer fso_framework_string_handling_enumFromString (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* value, gconstpointer default_value);
gpointer fso_framework_string_handling_enumFromName (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* name);
gpointer fso_framework_string_handling_enumFromNick (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* nick);
gchar* fso_framework_string_handling_enumToString (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer value);
gchar* fso_framework_string_handling_enumToNick (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer value);
static GEnumValue* _g_enum_value_dup (GEnumValue* self);
gpointer fso_framework_string_handling_convertEnum (GType f_type, GBoxedCopyFunc f_dup_func, GDestroyNotify f_destroy_func, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer from);
GHashTable* fso_framework_string_handling_splitKeyValuePairs (const gchar* str);
static void _g_free0_ (gpointer var);
gchar* fso_framework_string_handling_hexdump (guint8* array, int array_length1, gint linelength, const gchar* prefix, guchar unknownCharacter);
gchar* fso_framework_string_handling_filterByAllowedCharacters (const gchar* input, const gchar* allowed);


gchar* fso_framework_string_handling_stringListToString (gchar** list, int list_length1) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar* _tmp2_;
	gchar* res;
	_tmp0_ = list;
	_tmp0__length1 = list_length1;
	if (_tmp0__length1 == 0) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("[]");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = g_strdup ("[ ");
	res = _tmp2_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				gchar** _tmp7_;
				gint _tmp7__length1;
				const gchar* _tmp8_;
				gchar** _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				const gchar* _tmp11_;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				gchar* _tmp14_;
				gint _tmp15_;
				gchar** _tmp16_;
				gint _tmp16__length1;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = list;
				_tmp7__length1 = list_length1;
				if (!(_tmp6_ < _tmp7__length1)) {
					break;
				}
				_tmp8_ = res;
				_tmp9_ = list;
				_tmp9__length1 = list_length1;
				_tmp10_ = i;
				_tmp11_ = _tmp9_[_tmp10_];
				_tmp12_ = g_strdup_printf ("\"%s\"", _tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = g_strconcat (_tmp8_, _tmp13_, NULL);
				_g_free0 (res);
				res = _tmp14_;
				_g_free0 (_tmp13_);
				_tmp15_ = i;
				_tmp16_ = list;
				_tmp16__length1 = list_length1;
				if (_tmp15_ < (_tmp16__length1 - 1)) {
					const gchar* _tmp17_;
					gchar* _tmp18_;
					_tmp17_ = res;
					_tmp18_ = g_strconcat (_tmp17_, ", ", NULL);
					_g_free0 (res);
					res = _tmp18_;
				} else {
					const gchar* _tmp19_;
					gchar* _tmp20_;
					_tmp19_ = res;
					_tmp20_ = g_strconcat (_tmp19_, " ]", NULL);
					_g_free0 (res);
					res = _tmp20_;
				}
			}
		}
	}
	result = res;
	return result;
}


gpointer fso_framework_string_handling_enumFromString (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* value, gconstpointer default_value) {
	gpointer result = NULL;
	const gchar* _tmp0_;
	gpointer _tmp1_ = NULL;
	gpointer _result_;
	gconstpointer _tmp2_;
	g_return_val_if_fail (value != NULL, NULL);
	_tmp0_ = value;
	_tmp1_ = fso_framework_string_handling_enumFromName (t_type, (GBoxedCopyFunc) t_dup_func, t_destroy_func, _tmp0_);
	_result_ = _tmp1_;
	_tmp2_ = _result_;
	if (((gint) _tmp2_) == (-1)) {
		const gchar* _tmp3_;
		gpointer _tmp4_ = NULL;
		gconstpointer _tmp5_;
		_tmp3_ = value;
		_tmp4_ = fso_framework_string_handling_enumFromNick (t_type, (GBoxedCopyFunc) t_dup_func, t_destroy_func, _tmp3_);
		_t_destroy_func0 (_result_);
		_result_ = _tmp4_;
		_tmp5_ = _result_;
		if (((gint) _tmp5_) == (-1)) {
			gconstpointer _tmp6_;
			gpointer _tmp7_;
			_tmp6_ = default_value;
			_tmp7_ = ((_tmp6_ != NULL) && (t_dup_func != NULL)) ? t_dup_func ((gpointer) _tmp6_) : ((gpointer) _tmp6_);
			_t_destroy_func0 (_result_);
			_result_ = _tmp7_;
		}
	}
	result = _result_;
	return result;
}


gchar* fso_framework_string_handling_enumToString (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer value) {
	gchar* result = NULL;
	GTypeClass* _tmp0_ = NULL;
	GEnumClass* ec;
	GEnumClass* _tmp1_;
	gconstpointer _tmp2_;
	GEnumValue* _tmp3_ = NULL;
	GEnumValue* ev;
	gchar* _tmp4_ = NULL;
	GEnumValue* _tmp5_;
	_tmp0_ = g_type_class_ref (t_type);
	ec = (GEnumClass*) _tmp0_;
	_tmp1_ = ec;
	_tmp2_ = value;
	_tmp3_ = g_enum_get_value (_tmp1_, (gint) _tmp2_);
	ev = _tmp3_;
	_tmp5_ = ev;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_ = NULL;
		gconstpointer _tmp7_;
		gchar* _tmp8_ = NULL;
		_tmp6_ = g_type_name (t_type);
		_tmp7_ = value;
		_tmp8_ = g_strdup_printf ("Unknown Enum value for %s: %i", _tmp6_, (gint) _tmp7_);
		_g_free0 (_tmp4_);
		_tmp4_ = _tmp8_;
	} else {
		GEnumValue* _tmp9_;
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp9_ = ev;
		_tmp10_ = (*_tmp9_).value_name;
		_tmp11_ = g_strdup (_tmp10_);
		_g_free0 (_tmp4_);
		_tmp4_ = _tmp11_;
	}
	result = _tmp4_;
	_g_type_class_unref0 (ec);
	return result;
}


static GEnumValue* _g_enum_value_dup (GEnumValue* self) {
	GEnumValue* dup;
	dup = g_new0 (GEnumValue, 1);
	memcpy (dup, self, sizeof (GEnumValue));
	return dup;
}


static gpointer __g_enum_value_dup0 (gpointer self) {
	return self ? _g_enum_value_dup (self) : NULL;
}


gchar* fso_framework_string_handling_enumToNick (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer value) {
	gchar* result = NULL;
	GTypeClass* _tmp0_ = NULL;
	GEnumClass* ec;
	GEnumClass* _tmp1_;
	gconstpointer _tmp2_;
	GEnumValue* _tmp3_ = NULL;
	GEnumValue* _tmp4_;
	GEnumValue* ev;
	gchar* _tmp5_ = NULL;
	GEnumValue* _tmp6_;
	_tmp0_ = g_type_class_ref (t_type);
	ec = (GEnumClass*) _tmp0_;
	_tmp1_ = ec;
	_tmp2_ = value;
	_tmp3_ = g_enum_get_value (_tmp1_, (gint) _tmp2_);
	_tmp4_ = __g_enum_value_dup0 (_tmp3_);
	ev = _tmp4_;
	_tmp6_ = ev;
	if (_tmp6_ == NULL) {
		const gchar* _tmp7_ = NULL;
		gconstpointer _tmp8_;
		gchar* _tmp9_ = NULL;
		_tmp7_ = g_type_name (t_type);
		_tmp8_ = value;
		_tmp9_ = g_strdup_printf ("Unknown Enum value for %s: %i", _tmp7_, (gint) _tmp8_);
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp9_;
	} else {
		GEnumValue* _tmp10_;
		const gchar* _tmp11_;
		gchar* _tmp12_;
		_tmp10_ = ev;
		_tmp11_ = (*_tmp10_).value_nick;
		_tmp12_ = g_strdup (_tmp11_);
		_g_free0 (_tmp5_);
		_tmp5_ = _tmp12_;
	}
	result = _tmp5_;
	_g_free0 (ev);
	_g_type_class_unref0 (ec);
	return result;
}


gpointer fso_framework_string_handling_enumFromName (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* name) {
	gpointer result = NULL;
	GTypeClass* _tmp0_ = NULL;
	GEnumClass* ec;
	GEnumClass* _tmp1_;
	const gchar* _tmp2_;
	GEnumValue* _tmp3_ = NULL;
	GEnumValue* _tmp4_;
	GEnumValue* ev;
	gint _tmp5_ = 0;
	GEnumValue* _tmp6_;
	gint _tmp9_;
	gpointer _tmp10_;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = g_type_class_ref (t_type);
	ec = (GEnumClass*) _tmp0_;
	_tmp1_ = ec;
	_tmp2_ = name;
	_tmp3_ = g_enum_get_value_by_name (_tmp1_, _tmp2_);
	_tmp4_ = __g_enum_value_dup0 (_tmp3_);
	ev = _tmp4_;
	_tmp6_ = ev;
	if (_tmp6_ == NULL) {
		_tmp5_ = -1;
	} else {
		GEnumValue* _tmp7_;
		gint _tmp8_;
		_tmp7_ = ev;
		_tmp8_ = (*_tmp7_).value;
		_tmp5_ = _tmp8_;
	}
	_tmp9_ = _tmp5_;
	_tmp10_ = ((_tmp9_ != NULL) && (t_dup_func != NULL)) ? t_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
	result = _tmp10_;
	_g_free0 (ev);
	_g_type_class_unref0 (ec);
	return result;
}


gpointer fso_framework_string_handling_enumFromNick (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* nick) {
	gpointer result = NULL;
	GTypeClass* _tmp0_ = NULL;
	GEnumClass* ec;
	GEnumClass* _tmp1_;
	const gchar* _tmp2_;
	GEnumValue* _tmp3_ = NULL;
	GEnumValue* _tmp4_;
	GEnumValue* ev;
	gint _tmp5_ = 0;
	GEnumValue* _tmp6_;
	gint _tmp9_;
	gpointer _tmp10_;
	g_return_val_if_fail (nick != NULL, NULL);
	_tmp0_ = g_type_class_ref (t_type);
	ec = (GEnumClass*) _tmp0_;
	_tmp1_ = ec;
	_tmp2_ = nick;
	_tmp3_ = g_enum_get_value_by_nick (_tmp1_, _tmp2_);
	_tmp4_ = __g_enum_value_dup0 (_tmp3_);
	ev = _tmp4_;
	_tmp6_ = ev;
	if (_tmp6_ == NULL) {
		_tmp5_ = -1;
	} else {
		GEnumValue* _tmp7_;
		gint _tmp8_;
		_tmp7_ = ev;
		_tmp8_ = (*_tmp7_).value;
		_tmp5_ = _tmp8_;
	}
	_tmp9_ = _tmp5_;
	_tmp10_ = ((_tmp9_ != NULL) && (t_dup_func != NULL)) ? t_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
	result = _tmp10_;
	_g_free0 (ev);
	_g_type_class_unref0 (ec);
	return result;
}


gpointer fso_framework_string_handling_convertEnum (GType f_type, GBoxedCopyFunc f_dup_func, GDestroyNotify f_destroy_func, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer from) {
	gpointer result = NULL;
	gconstpointer _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* s;
	gpointer _tmp2_ = NULL;
	_tmp0_ = from;
	_tmp1_ = fso_framework_string_handling_enumToNick (f_type, (GBoxedCopyFunc) f_dup_func, f_destroy_func, _tmp0_);
	s = _tmp1_;
	_tmp2_ = fso_framework_string_handling_enumFromNick (t_type, (GBoxedCopyFunc) t_dup_func, t_destroy_func, s);
	result = _tmp2_;
	_g_free0 (s);
	return result;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


GHashTable* fso_framework_string_handling_splitKeyValuePairs (const gchar* str) {
	GHashTable* result = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _result_;
	GRegex* _tmp3_;
	GMatchInfo* mi = NULL;
	GRegex* _tmp6_;
	const gchar* _tmp7_;
	GMatchInfo* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	gboolean next;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_free0_);
	_result_ = _tmp2_;
	_tmp3_ = _keyValueRe;
	if (_tmp3_ == NULL) {
		{
			GRegex* _tmp4_;
			GRegex* _tmp5_;
			_tmp4_ = g_regex_new ("(?P<key>[A-Za-z0-9]+)=(?P<value>[A-Za-z0-9.]+)", 0, 0, &_inner_error_);
			_tmp5_ = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch19_g_regex_error;
				}
				_g_hash_table_unref0 (_result_);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_g_regex_unref0 (_keyValueRe);
			_keyValueRe = _tmp5_;
		}
		goto __finally19;
		__catch19_g_regex_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
		__finally19:
		if (_inner_error_ != NULL) {
			_g_hash_table_unref0 (_result_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp6_ = _keyValueRe;
	_tmp7_ = str;
	_tmp9_ = g_regex_match (_tmp6_, _tmp7_, G_REGEX_MATCH_NEWLINE_CR, &_tmp8_);
	_g_match_info_free0 (mi);
	mi = _tmp8_;
	next = _tmp9_;
	while (TRUE) {
		gboolean _tmp10_;
		GHashTable* _tmp11_;
		GMatchInfo* _tmp12_;
		gchar* _tmp13_ = NULL;
		GMatchInfo* _tmp14_;
		gchar* _tmp15_ = NULL;
		_tmp10_ = next;
		if (!_tmp10_) {
			break;
		}
		_tmp11_ = _result_;
		_tmp12_ = mi;
		_tmp13_ = g_match_info_fetch_named (_tmp12_, "key");
		_tmp14_ = mi;
		_tmp15_ = g_match_info_fetch_named (_tmp14_, "value");
		g_hash_table_insert (_tmp11_, _tmp13_, _tmp15_);
		{
			GMatchInfo* _tmp16_;
			gboolean _tmp17_ = FALSE;
			gboolean _tmp18_;
			_tmp16_ = mi;
			_tmp17_ = g_match_info_next (_tmp16_, &_inner_error_);
			_tmp18_ = _tmp17_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch20_g_regex_error;
				}
				_g_match_info_free0 (mi);
				_g_hash_table_unref0 (_result_);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			next = _tmp18_;
		}
		goto __finally20;
		__catch20_g_regex_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			next = FALSE;
			_g_error_free0 (e);
		}
		__finally20:
		if (_inner_error_ != NULL) {
			_g_match_info_free0 (mi);
			_g_hash_table_unref0 (_result_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = _result_;
	_g_match_info_free0 (mi);
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


gchar* fso_framework_string_handling_hexdump (guint8* array, int array_length1, gint linelength, const gchar* prefix, guchar unknownCharacter) {
	gchar* result = NULL;
	guint8* _tmp0_;
	gint _tmp0__length1;
	gchar* _tmp2_;
	gchar* _result_;
	gint _tmp3_;
	gint BYTES_PER_LINE;
	const gchar* _tmp4_;
	GString* _tmp5_;
	GString* hexline;
	GString* _tmp6_;
	GString* ascline;
	guchar b = '\0';
	gint i = 0;
	gint _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	const gchar* _tmp55_;
	gchar* _tmp56_ = NULL;
	g_return_val_if_fail (prefix != NULL, NULL);
	_tmp0_ = array;
	_tmp0__length1 = array_length1;
	if (_tmp0__length1 < 1) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = g_strdup ("");
	_result_ = _tmp2_;
	_tmp3_ = linelength;
	BYTES_PER_LINE = _tmp3_;
	_tmp4_ = prefix;
	_tmp5_ = g_string_new (_tmp4_);
	hexline = _tmp5_;
	_tmp6_ = g_string_new ("");
	ascline = _tmp6_;
	{
		gboolean _tmp7_;
		i = 0;
		_tmp7_ = TRUE;
		while (TRUE) {
			gboolean _tmp8_;
			gint _tmp10_;
			guint8* _tmp11_;
			gint _tmp11__length1;
			guint8* _tmp12_;
			gint _tmp12__length1;
			gint _tmp13_;
			guint8 _tmp14_;
			GString* _tmp15_;
			guchar _tmp16_;
			gboolean _tmp17_ = FALSE;
			guchar _tmp18_;
			gboolean _tmp20_;
			gint _tmp24_;
			gint _tmp25_;
			gint _tmp26_;
			_tmp8_ = _tmp7_;
			if (!_tmp8_) {
				gint _tmp9_;
				_tmp9_ = i;
				i = _tmp9_ + 1;
			}
			_tmp7_ = FALSE;
			_tmp10_ = i;
			_tmp11_ = array;
			_tmp11__length1 = array_length1;
			if (!(_tmp10_ < _tmp11__length1)) {
				break;
			}
			_tmp12_ = array;
			_tmp12__length1 = array_length1;
			_tmp13_ = i;
			_tmp14_ = _tmp12_[_tmp13_];
			b = (guchar) _tmp14_;
			_tmp15_ = hexline;
			_tmp16_ = b;
			g_string_append_printf (_tmp15_, "%02X ", (guint) _tmp16_);
			_tmp18_ = b;
			if (31 < ((gint) _tmp18_)) {
				guchar _tmp19_;
				_tmp19_ = b;
				_tmp17_ = ((gint) _tmp19_) < 128;
			} else {
				_tmp17_ = FALSE;
			}
			_tmp20_ = _tmp17_;
			if (_tmp20_) {
				GString* _tmp21_;
				guchar _tmp22_;
				_tmp21_ = ascline;
				_tmp22_ = b;
				g_string_append_printf (_tmp21_, "%c", (gint) _tmp22_);
			} else {
				GString* _tmp23_;
				_tmp23_ = ascline;
				g_string_append_printf (_tmp23_, ".");
			}
			_tmp24_ = i;
			_tmp25_ = BYTES_PER_LINE;
			_tmp26_ = BYTES_PER_LINE;
			if (((_tmp24_ % _tmp25_) + 1) == _tmp26_) {
				GString* _tmp27_;
				GString* _tmp28_;
				const gchar* _tmp29_;
				const gchar* _tmp30_;
				GString* _tmp31_;
				const gchar* _tmp32_;
				gchar* _tmp33_;
				const gchar* _tmp34_;
				gchar* _tmp35_;
				const gchar* _tmp36_;
				GString* _tmp37_;
				GString* _tmp38_;
				_tmp27_ = hexline;
				_tmp28_ = ascline;
				_tmp29_ = _tmp28_->str;
				g_string_append (_tmp27_, _tmp29_);
				_tmp30_ = _result_;
				_tmp31_ = hexline;
				_tmp32_ = _tmp31_->str;
				_tmp33_ = g_strconcat (_tmp30_, _tmp32_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp33_;
				_tmp34_ = _result_;
				_tmp35_ = g_strconcat (_tmp34_, "\n", NULL);
				_g_free0 (_result_);
				_result_ = _tmp35_;
				_tmp36_ = prefix;
				_tmp37_ = g_string_new (_tmp36_);
				_g_string_free0 (hexline);
				hexline = _tmp37_;
				_tmp38_ = g_string_new ("");
				_g_string_free0 (ascline);
				ascline = _tmp38_;
			}
		}
	}
	_tmp39_ = i;
	_tmp40_ = BYTES_PER_LINE;
	_tmp41_ = BYTES_PER_LINE;
	if ((_tmp39_ % _tmp40_) != _tmp41_) {
		GString* _tmp46_;
		GString* _tmp47_;
		const gchar* _tmp48_;
		const gchar* _tmp49_;
		GString* _tmp50_;
		const gchar* _tmp51_;
		gchar* _tmp52_;
		const gchar* _tmp53_;
		gchar* _tmp54_;
		while (TRUE) {
			GString* _tmp42_;
			gssize _tmp43_;
			gint _tmp44_;
			GString* _tmp45_;
			_tmp42_ = hexline;
			_tmp43_ = _tmp42_->len;
			_tmp44_ = BYTES_PER_LINE;
			if (!(_tmp43_ < ((gssize) (3 * _tmp44_)))) {
				break;
			}
			_tmp45_ = hexline;
			g_string_append_c (_tmp45_, ' ');
		}
		_tmp46_ = hexline;
		_tmp47_ = ascline;
		_tmp48_ = _tmp47_->str;
		g_string_append (_tmp46_, _tmp48_);
		_tmp49_ = _result_;
		_tmp50_ = hexline;
		_tmp51_ = _tmp50_->str;
		_tmp52_ = g_strconcat (_tmp49_, _tmp51_, NULL);
		_g_free0 (_result_);
		_result_ = _tmp52_;
		_tmp53_ = _result_;
		_tmp54_ = g_strconcat (_tmp53_, "\n", NULL);
		_g_free0 (_result_);
		_result_ = _tmp54_;
	}
	_tmp55_ = _result_;
	_tmp56_ = string_strip (_tmp55_);
	result = _tmp56_;
	_g_string_free0 (ascline);
	_g_string_free0 (hexline);
	_g_free0 (_result_);
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


gchar* fso_framework_string_handling_filterByAllowedCharacters (const gchar* input, const gchar* allowed) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* output;
	g_return_val_if_fail (input != NULL, NULL);
	g_return_val_if_fail (allowed != NULL, NULL);
	_tmp0_ = g_strdup ("");
	output = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				const gchar* _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				const gchar* _tmp8_;
				gint _tmp9_;
				gchar _tmp10_ = '\0';
				gchar* _tmp11_ = NULL;
				gchar* str;
				const gchar* _tmp12_;
				const gchar* _tmp13_;
				gboolean _tmp14_ = FALSE;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = input;
				_tmp6_ = strlen (_tmp5_);
				_tmp7_ = _tmp6_;
				if (!(_tmp4_ < _tmp7_)) {
					break;
				}
				_tmp8_ = input;
				_tmp9_ = i;
				_tmp10_ = string_get (_tmp8_, (glong) _tmp9_);
				_tmp11_ = g_strdup_printf ("%c", _tmp10_);
				str = _tmp11_;
				_tmp12_ = allowed;
				_tmp13_ = str;
				_tmp14_ = string_contains (_tmp12_, _tmp13_);
				if (_tmp14_) {
					const gchar* _tmp15_;
					const gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp15_ = output;
					_tmp16_ = str;
					_tmp17_ = g_strconcat (_tmp15_, _tmp16_, NULL);
					_g_free0 (output);
					output = _tmp17_;
				}
				_g_free0 (str);
			}
		}
	}
	result = output;
	return result;
}



